# 物理内存和虚拟内存

## 物理内存

计算机的主存是由多个连续的单元组成的，每个单元称为一个字节，每个字节都有一个唯一的物理地址 (Physical Address， PA)，地址编码是从 0 开始的。所以，如果计算机上配有 2G 的内存，那么，这个计算机可用的物理内存空间就是 0 到 2G。

直接操作物理内存的存在一个很大的问题：要求程序员手动对数据进行布局，那么内存不够用怎么办呢？而且，每个进程分配多少内存、如何保证指令中访存地址的正确性，这些问题都全部要程序员来负责。

在嵌入式设备中，手动管理内存的操作还是广泛存在的。这是因为在嵌入式开发中，往往没有进程的概念，也就是说整个应用独享全部内存，所以手动管理内存才有可能性。在单进程的系统中，所有的物理资源都是单一进程在管理，直接管理物理内存的操作复杂度还可以接受。

## 虚拟内存

### 局部性原理

在绝大多数程序的运行过程中，当前指令大概率都会引用最近访问过的数据。也就是说，程序的数据访问会表现出明显的倾向性。这种倾向性，我们就称之为局部性原理。

> 时间局部性：被访问过一次的内存位置很可能在不远的将来会被再次访问。
> 
> 空间局部性：如果一个内存位置被引用过，那么它邻近的位置在不远的将来也有很大概率会被访问。

基于这个原理，我们可以做出一个合理的推论：**无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的**。在这个推论的基础上，CPU 为每个进程只需要保留很少的物理内存就可以保证进程的正常执行了。

CPU 和操作系统还联手编织了一个假象：每个进程都独享 128T (64位只是用了低48位，所以是2^48=256T,2^32=4G)的虚拟内存空间，并且每个进程的地址空间都是相互隔离的。

### 虚拟内存

而直接操作虚拟内存非常简单。你可以独占 128T 内存，任意地使用，系统上还运行了哪些进程已经与我们完全没有关系了。为变量和函数分配地址的活，我们交给链接器去自动安排就可以了。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。

不过，任何一个虚拟内存里所存储的数据，还是保存在真实的物理内存里的。**任何虚拟内存最终都要映射到物理内存，但虚拟内存的大小又远超真实的物理内存的大小。**

CPU 充分利用程序局部性原理，提出了虚拟内存和物理内存的映射 (Mapping) 机制。

这种映射关系是以页为单位的。

虽然虚拟内存提供了很大的空间，但实际上进程启动之后，这些空间并不是全部都能使用的。开发者必须要使用 malloc（glibc中的内存分配接口） 等分配内存的接口才能将内存从待分配状态变成已分配状态。

在你得到一块虚拟内存以后，这块内存就是未映射状态，因为它并没有被映射到相应的物理内存，直到对该块内存进行读写时，操作系统才会真正地为它分配物理内存。然后这个页面才能成为正常页面。

在虚拟内存中连续的页面，在物理内存中不必是连续的。只要维护好从虚拟内存页到物理内存页的映射关系，你就能正确地使用内存了。这种映射关系是操作系统通过页表来自动维护的，不必你操心。

## 页表

映射的过程，是由 CPU 的内存管理单元 (Memory Management Unit, MMU) 自动完成的，但它依赖操作系统设置的页表。

页表的本质是页表项 (Page Table Entry, PTE) 的数组，虚拟空间中的每一个页在页表中都有一个 PTE 与之对应，PTE 中会记录这个虚拟内存页所对应的实际物理页的起始地址。

![内存页表](..\md\img\内存页表.png)

市面主流处理器选择将页表存储在内存页里，将页大小定为 4K。每个页表项都是 4 字节。所以，人们就将 1024 个页表项组成一张页表。这样一张页表的大小就刚好是 4K，占据一个内存页，这样就更加方便管理。

一个页表项对应着一个大小为 4K 的页，所以 1024 个页表项所能支持的空间就是 4M。那为了编码更多地址，我们必须使用更多的页表。而且，为了管理这些页表，我们还可以继续引入页表的数组：页目录表。

页目录表中的每一项叫做页目录项 (Page Directory Entry, PDE)，每个 PDE 都对应一个页表，它记录了页表开始处的物理地址，这就是多级页表结构。现代的 64 位处理器上，为了编码更大的空间，还存在更多级的页表。![Snipaste_2021-12-09_20-55-26](..\md\img\Snipaste_2021-12-09_20-55-26.png)

## CPU寻址

**第一步是确定页目录基址。**每个 CPU 都有一个页目录基址寄存器，最高级页表的基地址就存在这个寄存器里。在 X86 上，这个寄存器是 CR3。每一次计算物理地址时，MMU 都会从 CR3 寄存器中取出页目录所在的物理地址。

**第二步是定位页目录项（PDE）**。一个 32 位的虚拟地址可以拆成 10 位，10 位和 12 位三段，上一步找到的页目录表基址加上高 10 位的值乘以 4，就是页目录项的位置。这是因为，一个页目录项正好是 4 字节，所以 1024 个页目录项共占据 4096 字节，刚好组成一页，而 1024 个页目录项需要 10 位进行编码。这样，我们就可以通过最高 10 位找到该地址所对应的 PDE 了。

**第三步是定位页表项（PTE）**。页目录项里记录着页表的位置，CPU 通过页目录项找到页表的位置以后，再用中间 10 位计算页表中的偏移，可以找到该虚拟地址所对应的页表项了。页表项也是 4 字节的，所以一页之内刚好也是 1024 项，用 10 位进行编码。所以计算公式与上一步相似，用页表基址加上中间 10 位乘以 4，可以得到页表项的地址。

**最后一步是确定真实的物理地址**。上一步 CPU 已经找到页表项了，这里存储着物理地址，这才真正找到该虚拟地址所对应的物理页。虚拟地址的低 12 位，刚好可以对一页内的所有字节进行编码，所以我们用低 12 位来代表页内偏移。计算的公式是物理页的地址直接加上低 12 位。

# 进阶问题

### 一个是时间敏感型任务，缺页中断会大大降低服务的响应速度，应该从什么角度分析？

缺页中断比较多说明这个程序的局部性并不好，在物理内存足够的情况下，应该考虑让数据尽可能多的驻留在内存，所以我们可以考虑在服务启动时就分配虚拟内存。分配完成以后，在对虚拟内存空间做一次访问，强制吧未映射页面变成正常页面，从而降低缺页发生的概率。这个过程通常称之为内存的commit
