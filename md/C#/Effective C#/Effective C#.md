> 原版对照为《Effective C#》第三版，为 C#6.0 版本
> 
> 结合《深入理解 C#》第四版，为 C#7.0 版本。
> 
> 部分参考代码替换为 C# 8.0 版本，为手写代码大小写可能存在区别。。。
> 
> 意为打造个人使用 C#代码编程指南

# C#语言编程习惯

## 优先使用隐式类型的局部变量

合理的使用`var`

1. 只能使用`var`来声明局部变量
2. 例如对 `int`,`float`,`double`等数值类型，就应该明确的指出其数值类型。编译器有可能会发生数值类型的转换。
3. 不恰当的类型指定有时候反而会造成程序的执行效率下降。
4. 指定变量类型也未必能保证类型的安全，或是保证代码变的更加容易读懂。

## 考虑使用`readonly`代替`const`

C#有两种常量，一种是**编译期**的常量，一种是**运行期**的常量。

运行期的常量用`readonly`关键字来声明，编译期的常量使用`const`来声明。

例：

```
public const int num1=200;
public redonly int num2=200;

if(200==num1)在编译成微软中间语言的时候(IL)if(200==200)
而运行期的常量则会通过引用的方式调用num2这个readonly常量
```

编译期的常量只能用来表示内置的整数，浮点数，枚举和字符串。

在初始化语句里面设定这种常量的时候，只能使用这些值来为其赋值，在生成 IL 的过程中，也只有用来表示这些原始类型的编译期常量才会替换成字面量。使用 new 操作符来给编译期的常量做初始化是编译器不允许的。

```
public const DateTime data = new DateTime(2000, 1, 1,0,0,0);

//报错Constant initializer must be compile-time constant
//常量初始值设定项必须是编译时常量
```

** 编译期常量只能用数字，字符串或者 null 来初始化**

但是可以改用`readonly`来声明。这种常量可以在构造器里初始化，也可以在声明的时候直接初始化。

`readonly`可以用来声明实例级别的常量

最重要的区别在于：`readonly`是在程序运行的时候才解析的。代码中使用到这个变量的时候用到的是`readonly`量。而不是常量本身。这对代码维护有很大的影响。

在另一个程序集调用的时候，调用到的`const`常量会以字面值的形式写入到程序中。后期维护修改常量值的时候必须重构程序集。`readonly`则不用。

当然在使用一些固定信息的还是要使用`const`例如**版本号**。如果重构整个项目，每一个单独使用的版本号就会变成最新版本。如果只是使用补丁的方式来更新部分程序集，就只有部分的程序集版本会变。

当然`const`性能优于`readonly`。

## 优先考虑`is`或`as`运算符，尽量少用强者类型转换

转换类型时候使用` as`运算符，可以先通过`is`来判断是否合理。

数值类型的时候 使用 as 可能会返回 null 导致报错。

例如

```
object o=Factory.GetValue();
int i=o as int；//如果为空就会导致报错
//修改为
var i=o as int?;
if(i is null){

}
```

`foreach`语句的 as 使用强制类型转换实现的。它会把对象从 object 类型转换为循环体需要的类型。

应当尽量避免类型转换操作。必要时候应该采取 as 和 is 运算符来清晰的表达代码的意图。

使用 is 和 as 运算符几乎可以写出含义正确的代码，这两种运算符只会在受测对象确实可以进行类型转换的时候才会给出肯定的答案，而 cast(强制类型转换)与之相反，经常会产生违法预期的效果。

## 使用内插字符串代替`string.Format()`

字符串的内插机制是通过代码库来完成的。会在必要的时候把变量转换为`string`类型。

此时就要注意，其中用到数值类型的时候，需要将其自动转换为 object 类型。这种转换会进行装箱操作。一旦在循环中反复进行就会影响性能。应该先转换为字符串。

```
var str=$"double={double1.toString()}";
```

其中使用表达式的时候，应该使用括号包括起来。

## 用`FormattableString` 取代专门为特定区域而写的字符串

## 不要使用符号名称的硬字符串来调用 API

在调以变量名称为参数的 API 时，正确的使用`nameof`来获取该名称。

## 用委托表示回调

如果要在程序运行的时候执行回调，最好的方法是使用委托。

通过委托可以定义类型安全的回调。

委托是一种对象，其中包含指向方法的引用，这个方法可以是静态可以是实例。

lambda 就是一个简便的写法来表示委托。

所有的委托都是多播委托，会把添加到委托中的所有目标函数都视为一个整体去执行。

- 程序在执行这些目标函数的过程中可能会发生异常
- 程序会把最后执行的那个目标函数的返回值当为整个委托的结果

多播委托在执行的时候，不会捕获异常。只要抛出一个异常，调用链就会中断。

## 用`null`条件运算符调用事件处理程序

在触发事件之前，必须要判断时间处理程序是不是 null。

```
public void RaisUpdates(){
    counter++;
    if(Updated is not null){//Updated是一个委托
        Updated(this,counter);
    }
}
```

这种写法可以对付多种情况，但是还是有一个隐藏的 bug。在程序中的线程执行完 if 语句后发现 Updated 不等于 null 之后，可能会有另外的一个线程打断该线程，并将唯一的事件处理程序解除订阅，这样等早前的线程继续执行的 Updated(this,counter);的时候就变成了 null

```
public void RaisUpdates(){
    counter++;
    var handler=Updated;//使用浅拷贝保留事件处理程序
    if(handler is not null){
        handler(this,counter);
    }
}
```

这段代码的是通过浅拷贝为时间订阅者做了一个快照。等事件触发的时候，通知的事件处理程序就是快照记录下来的。

使用 null 条件运算符

```
public void RaisUpdates(){
    counter++;
    Updated?.Invoke(this,counter);
}
```

从语意上来看，和 if 结构类似，但是区别在于?.左侧的内容只会计算一次。

## 尽量避免装箱与取消装箱这两种操作

值类型是存放数据的容器，他们不应该设计为多态类型，但是 C#又必须设计 object 这种引用类型，并且放在程序的根部，这样所有的类型都成为由 object 所派生出的多态类型。

装箱的过程是把值类型放在非类型化的引用对象中，让那些需要使用引用类型的地方能够使用值类型。取消装箱是把已经装箱的那个值拷贝出来。

装箱会把值类型转换为引用类型，新创建的引用对象就像相当于箱子，他是分配在堆上面的，其中包含原值的拷贝。当外界需要调用的时候，系统就会把箱子里面的原址拷贝一份，并返回给调用者，这是取消装箱。

```
 Console.WriteLine($"int:{num1}");
 //编译器的执行逻辑类似于
 int num1=1;
 object 0=num1;
 Console.WriteLine(o.toString());
```

直接对值类型使用`toString()`方法会明确转换为 sting 类型，而不是编译器隐式的转换为 object。

如果是给集合里面放入值类型的值，就会发生装箱操作，从集合里面一处对象时，则需要给箱中的值做拷贝，应为凡是从箱子中获取的对象都需要给对象做拷贝。

**需要特别注意那些会把值类型转换为`System.Object`类型或者接口类型的地方。例如把值类型放入集合，用值类型的值来调用参数类型为 object 的方法等。**

## 只有在对应新版积累与现有子类之间的冲突时才应该使用 new 修饰符

# .NET 的资源管理

## 理解并善用.NET 的资源管理机制

## 声明字段时，尽量直接为其设定初始值

有时候开发者可能忘记给某些成员设定初始值。为了避免这个问题，最好是在声明的时候初始化，而不要等实现每一个构造函数的时候再去赋值。

没有构造函数也能把字段的初始值设定好

编译器会把这语句所生成的程序码放在本类的构造函数之前，执行的时机比基类构造函数更早。

经常使用的有：集合。

三种情况不应该使用：

- 把对象初始化为 0 或者 null，系统在执行开发者的代码之前，就会生成初始化逻辑，以便相关的内容全都这是为 0，这是通过底层的`cpu`指令来做的。C#编译器会按照你的要求添加相关指令，把这些内存再度清零，这虽然没错，但是会使代码变得脆弱
  
  ```
  public struct MyVla{
  
  }
  MyVal myVal;
  MyVal myVal2=new MyVal();
  ```
  
  这两种写法都可以把变量清零，第一条语句是吧包含`myVal`的内存设置为 0，第二天则是采用`intobj`这个条 IL 语句来清零，会触发正对 myVal2 变量的妆效与接触装箱操作。

- 如果不同的构造函数需要按照各自的方式来设定某一个字段的初始值，那么就要在编写初始化语句来。声明时的赋值会被构造函数中赋值所取代，等于创建两个。
  
  ```
  class MyCalss{
      private List<string> strs=new List<string>();
      MyClass(){}
      MyCalss(int size){
          strs=new List<string>(size);
      }
  }
  在编译器中相当于
  class MyCalss{
      private List<string> strs;
      MyClass(){
          strs=new List<string>();
      }
      MyCalss(int size){
          strs=new List<string>();
          strs=new List<string>(size);
      }
  }
  ```

- 如果初始化变量的过程中可能出现异常，就不要使用，而是应该把这个逻辑移到构造函数里面。

## 在适当的方法中初始化类中的静态成员

## 尽量删减重复的初始化逻辑

## 不要创建无畏的对象

## 绝对不要在构造函数里面调用虚函数

## 实现标准的 dispose 模式

# 合理的使用泛型

# 合理的使用 LINQ

## 优先考虑提供迭代器方法，而不要返回集合

你要写的很多方法其实都需要返回一系列的对象，而不是只返回一个对象，应该考虑将其写成迭代器的方法，使得调用者灵活的处理这些对象。

这是一种按需生成的策略，迭代器另一个重要的特点，就是序列中的元素由该方法创建出来的那个对象生成，只有调用方真正用到序列中某一个元素时程序才会通过那个对象创建该元素。这使得程序在调用生成器方法时只需要执行少量的代码。

## 优先考虑通过查询语句来编写代码，而不要使用循环语句

查询语句使得开发者能够以更加符合声明模式而非命令模型的写法来表达程序的逻辑，能够更加清晰的表达开发者的想法。

在编写循环结构，总是应该想想能不能改用查询语句来实现相同的功能，如果不行再想想能不能改用查询方法来解决。每一种命令式的循环结构集合都可以通过查询表达式更为清晰的写出来。

## 将迭代逻辑与操作，谓词及函数解耦

就是使用匿名委托或者 lambda 表达式，来对输入序列中的元素做处理。

## 等到正在用到序列中的元素的时再去生成

## 考虑通过函数参数来放松耦合关系

设计组件时，首先还是应该考虑是否能够把本组件和客户代码之间的沟通港式约定成为接口。如果有一些默认的实现代码需要编写，可以考虑放在抽象基类中。如果采用委托来描述本组件索要使用的方法，那么用起来会更加灵活，但是开发工具对此支持也更少。你需要写更多的代码才能保证这种灵活的设计正常工作。

## 绝对不要重载扩展方法

## 理解查询表达式与方法调用之间的映射关系
