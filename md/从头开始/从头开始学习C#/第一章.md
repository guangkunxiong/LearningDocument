# 基本概念

## CLR基础

**`CLR (Common language Runtime) `公共语言运行时**是一个可由多种变成语言使用的运行时。

非托管代码：使用`C/C++`代码可以对系统进行低级控制。例如按照自己的想法分配内存。

托管代码：面向CLR开发的代码。自动完成内存的分配和回收、跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。

微软创造了多个面向CLR的语言编译器包括：`C++/CLI`、`C#`、`VB`、`F#`、`Iron Python`、`Iron Ruby`和`IL(Microsoft  Intermediate Language )`中间语言汇编器。当然这些编译器生成的结果都是托管模块，它们都需要CLR才能运行。只有微软的`C++`编译器默认生成非托管模块。可以通过指定CLR来生产托管模块。只有`C++`可以同时写托管和非托管代码

### CLR执行模型

#### 托管模块

托管模块是标准的PE32(32位)或PE32+(64位)文件(.exe或.dll)。

托管模块的各个部分：

- PE头：PE 文件主要部分的索引和入口点的地址。	
- 元数据：元数据表和堆。 运行时使用该部分记录您的代码中每个类型和成员的信息。 本部分还包括自定义特性和安全性信息。
- IL代码：编译器生成的代码

元数据存储的信息

- 程序集的说明。
  - 标识（名称、版本、区域性、公钥）。
  - 导出的类型。
  - 该程序集所依赖的其他程序集。
  - 运行所需的安全权限。
- 类型的说明。
  - 名称、可见性、基类和实现的接口。
  - 成员（方法、字段、属性、事件、嵌套的类型）。
- 特性。
  - 修饰类型和成员的其他说明性元素。

元数据和他描述的IL代码是绑定在一起的。

元数据的用途和优点：

- 公共语言运行时模块和程序集是自描述的。 模块的元数据包含与另一个模块进行交互所需的全部信息。运行时模块和程序集甚至不需要向操作系统注册。
- .NET 允许在编译文件中声明特定种类的元数据（称为特性）。
- IDE的代码提示会解析元数据
- CLR通过元数据来验证类型安全
- 元数据允许垃圾回收跟踪对象生存期。

#### 托管执行过程

- 面向CLR的语言编译器编译为IL代码，并生成元数据。
- 执行时，实时` (JIT)` 编译器将 `IL` 转换为本机代码。或者使用 `Ngen.exe`（本机映像生成器）预编译模式，运行应用程序之前将 `IL` 转换为本机代码。 在此编译期间，代码必须通过检查 `IL` 和元数据的验证过程以查明是否可以将代码确定为类型安全。
- 运行代码，公共语言运行时提供启用要发生的执行的基础结构以及执行期间可使用的服务。

#### 程序集

程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。 程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元或者说是一个或多个模块/资源文件的逻辑性分组。 程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是 .NET 应用程序的构建基块 。在CLR的世界中程序集相当于“组件”。

编译器会默认将生成的托管模块转换成程序集。每个程序集都有一个程序集清单文件：

- 程序集的标识（名称和版本）。
- 文件表，描述构成程序集的其他所有文件（例如，.exe 或 .dll 文件所依赖的你创建的其他程序集、位图文件或自述文件） 。
- 程序集引用列表，即所有外部依赖项的列表，如 .dll 或其他文件 。 程序集既可以引用全局对象，也可以引用私有对象。 全局对象可用于所有其他应用程序。 在 .NET Core 中，全局对象与特定的 .NET Core 运行时结合使用。 在 .NET Framework 中，全局对象位于全局程序集缓存 (GAC) 中。 System.IO.dll 是 GAC 中程序集的一个示例。 私有对象必须位于级别不高于应用安装目录的目录中。

使用程序集连接器AL.exe可以将一组文件合并到程序集中。

#### 执行程序集的IL代码

为了执行方法必须把IL代码转换为本机的CPU指令。这是CLR的JIT(just-in-time)编译器的职责。

```c#
static void Main()
{
   Console.WriteLine("-.-");
}
```

一个方法首次调用时：

在执行Main方法之前，CLR会检测出Main代码引用的所有类型并分配一个内部的数据结构来管理对引用类型的访问。在内部数据结构中，使用类型的每一个都有一个对饮的记录项，每一个记录项都有一个地址，根据地址找到方法实现。初始化时,CLR将每一个记录项都指向为包含在CLR内部的一个未编档函数：`JITCompiler`。Main方法调用WriteLine方法时，`JITCompiler`函数会被调用。

##### `JITCompiler`

`JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的IL代码。`JITCompiler`验证IL代码后编译为CPU指令。本机的CPU指令保存在动态分配的内存块中。`JITCompiler`回到CLR创建的内存数据结构，修改初始化时候指向`JITCompiler`方法为内存块中编译后的CPU指令的地址。最后`JITCompiler`跳转到编译后的CPU指令。第二次调用WriteLine方法时，会直接执行内存块中的代码。

方法紧在首次调用的时候有一些性能损失。JIT编译器是将本机的CPU指令保存在内存中，所以程序一旦终止，编译后的代码也会被清除。

JIT还会对本机的代码进行优化。可以在C#编译器的开关进行设置。

当然可以使用`Ngen.exe`对程序集进行预编译。改工具会编译程序集的所有IL代码保存到一个磁盘文件中。在加载程序集的时，CLR自动判断是否存在预编译版，如果有则加载预编译代码。但是`Ngen.exe`编译的代码较为保守，因为并不清楚最终的执行环境。例如JIT会判断是否是运行在奔腾4CPU上（奔腾4的超长流水线设计需要生成不同的CPU指令来发挥其高吞吐率的优点和解决冒险带来的依赖关系问题），并生成特殊的指令。

## GC基础

### 自动内管理

手动内存管理虽然不会来带额外的内存管理的开销但是对于程序员来说比较麻烦，例如C/C++手动分配和Rust的所有权。

#### 引用计数

#### 跟踪回收器

核心思路是从Mutator的根开始递的跟踪整个对象图，来发现对象的真正可达性。

##### 保守跟踪回收器

##### 精确跟踪回收器

###### 标记阶段

###### 回收阶段

## C#和.Net Core

