# javaScript 悟道

## 第零章 导读

按照的版本是 ES6

此书使用 wun 代替 one。

## 第一章 命名

我希望你在命名的时候尽可能描述清楚被赋名者的含义，而不要使用各种隐晦的缩写。

JavaScript 中的所有名字都应该以小写字母开头，这一切都拜 JavaScript 中的`new`运算符所赐。如果一个函数名的前面有`new`，则代表该函数是一个构造函数，否则它就是一个普通函数。因此，我们应该做这样的约定：**所有的构造函数都应该以大写字母开头，而其他任何名字都应该以小写字母开头**。我们以此来给函数划分语义，从而使一些错误更容易被发现。

## 第二章 数值

avaScript 不像其他语言一样有整型、浮点型等数值类型，而是只有一个总称，叫**数值类型**。64 位的浮点数类型，一个`number`类型包含 1 位符号位（sign）、11 位指数位以及 53 位有效位数。有些神奇的编码能将 65 位数据装进 64 位内存中。

### 2.1 零

零是独一无二的。理论上来说，在一个数值系统中只应存在一个零。然而事不遂人愿，在 IEEE 754 标准中有两个零：`0`和`-0`。

```
(1 / 0) === (1 / -0)
// false
Object.is(0, -0)
// false
```

我真心建议你不要拿零做除数，也永远不要使用`Object.is()`

> `Object.is()`

方法判断两个值是否为[同一个值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。如果满足以下条件则两个值相等:

- 都是 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)
- 都是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)
- 都是 `true` 或 `false`
- 都是相同长度的字符串且相同字符按相同顺序排列
- 都是相同对象（意味着每个对象有同一个引用）
- 都是数字且
  - 都是 `+0`
  - 都是 `-0`
  - 都是 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)
  - 或都是非零而且非 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 且为同一个值

与[`==`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Operators_310dc67549939233c3d18a8fa2cdbb23#equality) 运算*不同。* `==` 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 `"" == false` 判断为 `true`), 而 `Object.is`不会强制转换两边的值。

与[`===`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Operators_310dc67549939233c3d18a8fa2cdbb23#identity) 运算也不相同。 `===` 运算符 (也包括 `==` 运算符) 将数字 `-0` 和 `+0` 视为相等 ，而将[`Number.NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN) 与[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)视为不相等.

### 2.2 数值字面量

`NaN`是一个特殊值，用于表示那些非数的数。

`NaN`是 Not a Number 的缩写，虽然它的含义是“不是一个数”，但是`typeof`对它的结果又告诉大家`NaN`是一个**数**（`"number"`）。

当字符串转换成数值失败时，结果就是`NaN`。当算术表达式中的一个数值为`NaN`的时候，它的运算结果也会是`NaN`。

因此，当我们要判断一个值是不是`NaN`时，应当使用`Number.isNaN(*value*)`。`Number.isFinite(*value*)`函数会在值为`NaN`、`Infinity`或者`-Infinity`的时候返回`false`。

### 2.3 Number

`Number`（注意首字母大写）是可以返回`number`类型值的函数。`number`类型在 JavaScript 中是不可变类型。在`number`类型变量前面使用`typeof`的时候，结果为`"number"`（注意首字母小写）。

不应该在`Number`函数前加上`new`这个运算符，因为它的行为跟你想象的不太一样。

```
const good_example = Number("432");
const bad_example = new Number("432");
typeof good_example
// "number"
typeof bad_example
// "object"
good_example === bad_example
// false
```

在 JavaScript 中，只有在所有的运算因子、运算结果以及中间结果都是安全整数的情况下，才能进行精确的整数运算，才适用于加法结合律和乘法分配律。一旦有一项的值不是安全整数，事情就会变得不那么可控。

例如，当我们计算一堆数的和时，相加的顺序会影响结果。举个例子，`((0.1 + 0.2) + 0.3)`的结果比`(0.1 + (0.2 + 0.3))`的结果大。我们可以通过`Number.isSafeInteger(*number*)`函数来判断一个数是否是安全整数。如果是，它会返回`true`。

我们基本上可以认为所有小于该值的正数都等同于 0。值得一提的是，`Number.MIN_VALUE`仅包含 1 位有效位数，在整个数值的最低位，因此该值也有很大程度的失精。

所有的数值类型都继承自`Number.prototype`对象。该对象包含一系列方法，但我觉得这些方法都没什么用。

### 2.4 运算符

### 2.5 位运算符

| `&`   | 与运算         |
| ----- | -------------- |
| `\|`  | 或运算         |
| `^`   | 异或运算       |
| `<<`  | 左移           |
| `>>>` | 右移           |
| `>>`  | 带符号扩展右移 |

### 2.6 Math 对象

`Math`对象包含一系列本该在`Number`中的重要函数。这是又一个从 Java 处习得的糟粕。该对象中有三角函数（trigonometric function）和对数函数（logarithmic function），以及一些本该是运算符的函数。

```
Math.floor(-2.5) // -3 返回的是一个恰比传入参数小的整数
Math.trunc(-2.5) // -2 返回的则是恰比传入参数更接近0的整数
```

### 2.7 怪物

## 第三章 高精度整数

## 第四章 高精度浮点数

## 第五章 高精度有理数

## 第六章 布尔类型

### 6.1 关系运算符

| `===` | 等于     |
| ----- | -------- |
| `!==` | 不等于   |
| `<`   | 小于     |
| `<=`  | 小于等于 |
| `>`   | 大于     |
| `>=`  | 大于等于 |

这两个运算符可用于确定一个值是否为`null`或者`undefined`，以及除了`NaN`之外的任何值。但如果要判断一个值`*x*`是不是`NaN`，请使用`Number.isNaN(x)`。

除非你肯定值的大小在安全整数范围内，否则不要通过`===`的条件判断来结束循环。即使在安全整数范围内，我也还是推荐使用`>=`。

任意数值与`NaN`进行任意比较都会返回`false`

当两个值都为字符串或者都为数值的时候，`<`、`<=`、`>`和`>=`的结果都是准确的。不过在其他情况下，这些比较大多是无意义的

**JavaScript 还有一些更不可靠的比较运算符。我建议你永远不要使用`==`和`!=`。这两个运算符在进行比较之前会做一些强制的类型转换，所以比较结果很可能有误。答应我，永远不要用这两个运算符；答应我，务必使用`===`和`!==`**

### 6.2 布尔式犯蠢类型

在一个设计良好的语言中，条件判断位置应该只允许使用布尔类型。然而 JavaScript 偏偏没有，它允许任意类型的值存在于这些位置中。在 JavaScript 中，所有类型都是“布尔式犯蠢类型”（boolish type）2 家族的一员。布尔式犯蠢类型里的值都可被归纳成**幻真**（truthy）或者**幻假**（falsy）。

幻假的值有：

- `false`
- `null`
- `undefined`
- `""`（空字符串）
- `0`
- `NaN`

剩下的值就全都是幻真的了，比如空对象、空数组，甚至`"false"`和`"0"`这样看起来像幻假的字符串。

理论上，一个条件判断的结果只应为`true`或`false`，其余的值都应该在编译时就抛错。然而 JavaScript 并非如此。

如果我们在编码的时候严于律己，就能写出更好的程序。

### 6.3 逻辑运算符

| `!`  | 逻辑非 | 如果运算值为幻真，则运算结果为`false`；否则为`true`                  |
| ---- | ------ | -------------------------------------------------------------------- | ------ | -------------------------------------------------------------------- |
| `&&` | 逻辑与 | 如果第一个运算值为幻假，则直接返回第一个运算值；否则返回第二个运算值 |
| `    |        | `                                                                    | 逻辑或 | 如果第一个运算值为幻真，则直接返回第一个运算值；否则返回第二个运算值 |

### 6.4 非

双重否定就是一个明显可被简化的逻辑表达式。在逻辑系统中，有

```
!!p === p
```

而在 JavaScript 中，上式仅当`p`是布尔类型时才成立。如果`p`是其他类型的值，那么`!!p`不一定等于`p`，而是等于`Boolean(p)`。

## 第七章 数组

- 数组有一个神奇的`length`属性。该属性并不是指数组中元素的数量，**而是指数组元素的最高序数加`1`**。这种神奇的设定可以让 JavaScript 数组假装自己“真的是数组”，从而让它在过时的`for`语句中被处理。之所以说它过时，是因为我们在半个世纪前的 C 语言程序中就可以找到这种写法。
- 数组对象都继承自`Array.prototype`，该原型比`Object.prototype`多了一些更实用的函数。

JavaScript 自身也对数组感到迷惑。如果对数组进行`typeof`操作，返回将是`"object"`，这显然是有问题的。如果要判断一个值是不是数组，得使用`Array.isArray(*value*)`。

### 7.1 原点

不过，我们有时还是不得不在意这一点。例如，first 这个单词就有歧义，所以书中用 zeroth（第零个）来代替 first，从而使我们的原点变得清晰。

| `[0]` | zeroth  | 第零个 |
| ----- | ------- | ------ |
| `[1]` | wunth   | 第一个 |
| `[2]` | twoth   | 第二个 |
| `[3]` | threeth | 第三个 |

### 7.2 初始化

```
let my_little_array = new Array(10).fill(0);
                    // my_little_array为[0, 0, 0, 0, 0, 0,0, 0, 0, 0]
let same_thing = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

my_little_array === same_thing
// false
```

虽然`my_little_array`和`same_thing`中的值是一样的，但它们是不同的数组。数组不是字符串，但是一些行为与对象类似，只有两个数组真的来自同一个引用的时候，它们才相等。

### 7.3 栈与队列

数组有一些方法让其与栈类似。`pop`方法返回数组中的最后一个元素，并将其从数组中移除。`push`方法则将传入的值附加到数组的末尾。

`shift`方法与`pop`类似，只不过移除并返回的是数组中的第零个元素。`unshift`则与`push`类似，只不过将元素插入数组的开头。就性能来说，`shift`和`unshift`比`pop`和`push`差很多，这种差异在数组很大的时候尤为明显。当我们将`shift`和`push`一起使用的时候，数组就会像一个队列——先进先出。

### 7.4 搜索

JavaScript 还提供了一些用于搜索的方法。`indexOf`方法将传入的值与数组中的元素从头开始一一对比。如果两值相等，该方法就会停止后续对比，直接返回该元素的序号。

如果遍历了整个数组还没有匹配的值，**则返回`-1`**。我个人认为这个设计有错误，因为`-1`也是一个数，与其他返回的序号都是数值类型。如果你在搜索数组后并没有在第一时间校验返回值是否为`-1`，后续的运算结果很有可能会在没有任何警告的情况下开始出错。JavaScript 还有很多类似的设计错误，这些底型在一开始设计的时候就有问题。

`lastIndexOf`函数与`indexOf`类似，只不过前者是从后往前搜索的。与`indexOf`一样，它也用`-1`来代表搜索失败。

`includes`函数也与`indexOf`类似，只不过前者不返回序数，而是返回`true`来代表数组中存在搜索值，返回`false`来代表不存在。

### 7.5 规约

`reduce`函数用于将数组的值归约为单个值。它的参数是一个有两个参数的函数。

`reduce`会循环调用这个传入的参数，直到遍历完整个数组。

reduce 函数传入值：
**`callback`**
执行数组中每个值 (如果没有提供 `initialValue则第一个值除外`)的函数，包含四个参数：

- `accumulator` 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`（见于下方）。
- `currentValue`
  数组中正在处理的元素。
- `index` 可选
  数组中正在处理的当前元素的索引。 如果提供了`initialValue`，则起始索引号为 0，否则从索引 1 起始。
- `array`可选
  调用`reduce()`的数组

**`initialValue`**可选
作为第一次调用 `callback`函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。

```
function add(reduction, element) {
    return reduction + element;
}

let my_little_array = [3, 5, 7, 11];

let total = my_little_array.reduce(add, 0);  // total为26
每次调用add函数的时候，实际参数如下
(0, 3)    // 3
(3, 5)    // 8
(8, 7)    // 15
(15, 11)  // 26
```

无需传入初始值：

```
total = my_little_array.reduce(add);  // 26
(3, 5)    // 8
(8, 7)    // 15
(15, 11)  // 26
```

看，比之前少了一次调用吧。而且在这种情况下，就不会像之前一样出现由于错误的初始值而导致的惨剧了。

> 示例代码，使用 reduce 函数来计算书籍的 ISBN 的校验位（check digit，即 ISBN 的最后一位数字）。

```
function isbn_13_check_digit(isbn_12) {
  const string_of_digits = isbn_12.replace(/-/g,"");
  if (string_of_digits.length === 12) {
    const check = string_of_digits.split("").reduce(
      function (reduction, digit, digit_nr) {
        return reduction + (
          digit_nr % 2 === 0
          ? Number(digit)
          : Number(digit) * 3
        );
      },
      0
    ) % 10;
    return (
      check > 0
      ? 10 - check
      : check
    );
  }
}

isbn_13_check_digit("978-1-94-981500")  // 9
```

### 7.6 遍历

`forEach`方法将一个函数作用于数组——它将为数组中的每个元素执行一遍传入的函数。传入的函数可以接收三个参数：`element`、`element_nr`和`array`。`element`表示当前正在处理的元素。`element_nr`则是当前元素的序号，以备不时之需。`array`其实是一个美丽的错误，真的非常多余。有了它，你有时候就会忍不住去修改数组，但修改正在运算中的数组真的不是一个明智的举动。

- `every`方法关注其传入函数的返回值。如果传入的函数返回幻假值，`every`方法会停止遍历并直接返回`false`；如果传入的函数返回幻真值，`every`方法则会继续遍历。遍历完整个数组，`every`方法就会返回一个`true`。
- `some`方法与`every`类似。我至今依然困惑：都说一山不容二虎，为什么 JavaScript 还要让这两个方法共存呢？如果传入的函数返回幻真值，`some`会停止遍历并直接返回`true`；如果传入的函数返回幻假值，`some`方法则会继续遍历。遍历完整个数组，`some`方法会返回一个`false`。
- `find`方法与`some`类似，只不过最终返回的不是语义上的`true`或者`false`，而是当遍历到函数返回一个幻真值的时候，直接返回当前处理的元素。
- `findIndex`方法与`find`类似，只不过返回的不是一个元素，而是相应元素的序号。
- `filter`方法也与`find`类似，只不过返回的是一个新数组，其中依次包含那些遍历处理时返回幻真值的元素。总得来说就是`find`返回的是第一次匹配到的元素，而`filter`则返回所有的匹配项。
- `map`方法与`forEach`类似，只不过会将所有经过处理后的元素放到一个新的数组中返回。`map`方法是转换元素得出新数组的“神器”。

`forEach`和`find`方法都有提前退出的能力（`every`和`some`就是`forEach`的可提前退出形态）。`map`、`reduce`和`filter`则没有这个能力。

### 7.7 排序

JavaScript 有一个`sort`方法。然而，这个方法存在不少问题。

排序方法是原地生效的——它会修改原数组。也就是说`sort`方法无法对冻结数组进行排序，而且对共享型数组（shared array）进行排序操作也不安全。

`sort`方法的默认比较函数会将所有比较对象都转成字符串，即便里面的元素都是数。下面是一个例子。

```
let my_little_array = [11, 2, 23, 13, 3, 5, 17, 7, 29, 19];
my_little_array.sort();
// my_little_array为[11, 13, 17, 19, 2, 23, 29, 3, 5, 7]
```

`sort`方法还有一个比较严重的问题，那就是缺乏稳定性。在比较两个相等值的时候（比较函数会返回`0`），如果排序方法将这两个值排在它们原来的位置上，则可以说该排序方法是稳定的。可惜的是 JavaScript 并不具备该稳定性，第二遍排序会把第一遍已经排好的姓打乱。

### 7.8 大杂烩

`concat`方法可以将两个或更多数组拼接起来并返回一个新数组。

```
let part_zero = ["unicorns","rainbows"];
let part_wun = ["butterflies","monsters"];
let whole = part_zero.concat(part_wun);
            // whole的值为["unicorns","rainbows","butterflies","monsters"]
```

`join`方法用分隔符将字符串数组拼接成一个新的字符串。它可能会产出一个包罗万象的巨型字符串。如果你不想用分隔符进行拼接，则可以传入一个空字符串。`join`其实是字符串`split`方法的逆方法。

```
let string = whole.join(" & ");
             // string的值为"unicorns & rainbows & butterflies & monsters"
```

`reverse`方法会将数组逆序重排。与`sort`方法一样，这个方法也具有破坏性。

```
whole.reverse();
             // whole的值为["monsters","butterflies","rainbows","unicorns"]
```

`slice`方法会产出原数组的副本，或者原数组的部分副本。该方法的第零个参数决定了从第几个元素开始；第一个参数的值为第零个参数加上需要复制的元素个数。如果第一个参数没传，则余下的所有元素都会被复制。

```
let element_nr = whole.indexOf("butterflies");
let good_parts;
if (element_nr !== -1) {
    good_parts = whole.slice(element_nr);
}
            // good_parts的值为["butterflies","rainbows","unicorns"]
```

### 7.9 数组函数

数组就像一个森林，里面有很多方法函“树”。有些方法纯净如水，并不会私下改变任何入参；而有些则不。在这些非纯方法中，有一些本该纯净；而还有一些天生就无法纯净，却依然有价值

“纯净之树”：

```
concat 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。
every 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
filter 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
find 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
findIndex 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
forEach 方法对数组的每个元素执行一次给定的函数。
indexOf 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
join 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。
lastIndexOf 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
map 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
reduce 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。
reduceRight  方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。
slice 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
some 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。
```

- “非纯之树”：

  ```
  fill 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
  pop 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
  push 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
  shift 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
  splice 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
  unshift 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。
  ```

- “污染之树”（本该纯净）：

  ```
  reverse 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。
  sort 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的
  ```

## 第八章 对象

在 JavaScript 中，首等数据结构被称为**对象**（object）。对象即一系列属性（或成员）的容器，各属性都由键名和键值组成，其中键名为字符串，键值可以为任意类型。在其他语言中，这类数据结构通常被称为**哈希表**（hash table）、**映射表**（map）、**记录**（record）、**结构体**（struct）、**关联数组**（associative array）或**字**

**如果通过点表示法或者方括号表示法访问对象中不存在的属性，那么 JavaScript 就会返回`undefined`这个底型。在 JavaScript 中，访问对象中不存在的属性并不会被视为异常——返回`undefined`是常规操作。**（dictionary），还有些语言干脆直接用`dict`来代替它。

要删除某个属性，正确的做法是使用`delete`运算符。

```
delete my_little_object["0/0"];
```

当对一个对象执行`typeof`操作的时候，返回值是字符串`"object"`。

```
typeof my_little_object ==="object"
// true
```

### 8.1 区分大小写

对象属性的键名是区分大小写的，也就是说，`my_little_object.cat`与`my_little_object.Cat`是不一样的属性。在匹配键名的时候，JavaScript 是用`===`运算符对两个字符串进行匹配的。

### 8.2 复制

`Object.assign`函数可以将一个对象中的属性复制到另一个对象中。你可以通过这个函数来将一个对象复制到一个空对象上。

```
let my_copy = Object.assign({}, my_little_object);
my_copy.bar              // "a long rod or rigid piece of wood or metal"
my_copy.age
// 39
my_copy.age += 1;
my_copy.age
// 40
delete my_copy.age;
my_copy.age
// undefined
```

一个对象可以被很多对象赋值。所以我们可以用这个方法来将多个简单对象组装成一个复杂对象。

### 8.3 继承

在 JavaScript 中，一个对象可以从另一个对象中继承而来。与那些具有较高耦合性程序结构（如类）的语言相比，这并不是一种常态的继承形式。在 JavaScript 中具有耦合性的是数据，从而让整个应用架构不那么脆弱。

`Object.create(*prototype*)`可以将一个已有的对象继承到一个新对象中。该已有对象将作为新对象的原型。同理，这个新对象还可以继续作为下一个新对象的原型。JavaScript 并没有限制原型链的长度，但是我的建议是不要让整条原型链过长。

```
let my_clone = Object.create(my_little_object);
my_clone.bar             // "a long rod or rigid piece of wood or metal"
my_clone.age
// 39
my_clone.age += 1;
my_clone.age
// 40
delete my_clone.age;
my_clone.age
// 39
```

我们用原型做得最多的事情就是来存储函数。实际上，JavaScript 这门语言本身的各种对象都是这么做的。当我们用对象字面量创建对象的时候，JavaScript 默认其继承自`Object.prototype`。类似地，数组方法继承自`Array.prototype`；数值类型方法则继承自`Number.prototype`；字符串方法继承自`String.prototype`；甚至连函数方法也是继承自`Function.prototype`的。数组方法和字符串方法都比较有用，而`Object.prototype`的方法则比较鸡肋。

因为这种继承模式的存在，JavaScript 对象有两种类型的属性：浮于最表面的**自有属性**（own property），以及原型链上的**继承属性**（inherited property）。在大多数情况下，我们并不需要关心这些属性的类型。但还有些情况需要我们知道一个属性是否是对象的自有属性。大多数对象继承了`hasOwnProperty(string)`方法，然而这个方法其实有可靠性风险。理论上，该方法会判断对应对象上是否存在传入的属性键名，且该属性是一个自有属性。如果这个对象上有一个自有属性也叫`hasOwnProperty`，那么我们调用的实际上是自有的`hasOwnProperty`。这是一个陷阱，需要谨慎对待。我觉得把`hasOwnProperty`设计成运算符会好很多，也就不会有陷阱存在了。我甚至觉得没有继承属性会更好，可以直接省去各种麻烦。

```
my_little_object.hasOwnProperty("bar")
// true
my_copy.hasOwnProperty("bar")
// true
my_clone.hasOwnProperty("bar")
// false
my_clone.hasOwnProperty = 7;
my_clone.hasOwnProperty("bar")
// 异常！
```

`Object.prototype.toString`也存在类似的风险。其实，就算没有可靠性风险，这个方法的表现也着实令人不满。

```
my_clone.toString() // "[object Object]"
```

如果想将对象转换成字符串，`JSON.stringify`做得可比它精彩多了。

**`Object.create(null)`会创建一个“纯”对象**，该对象没有任何继承属性。这样一来，各种继承带来的困惑（如意外继承等）都将不复存在。在这个对象中，只有我们自己明确存进去的属性，并不会有其他多余的内容。事实上，现在的我就非常喜欢用`Object.create(null)`。

### 8.4 键名

`Object.keys(*object*)`函数会将传入对象的所有自有属性（不包括继承属性）的键名作为字符串放入一个数组中并返回。这样一来，你就可以用数组的各种方法去处理对象的属性了。

键名在数组中的顺序是按属性的插入时间来排列的。如果你想改变排列顺序，只需调用数组的`sort`方法即可。

### 8.5 冻结

`Object.freeze(object)`可以将对象冻结，使其成为不可变（immutable）对象。“不可变”特性可以增加程序的可靠性。一旦你创建了自己看着顺眼的对象，就可以将其冻结，以此来防止破坏和篡改。需要注意的是，该操作并不是深度冻结，只有对象最顶层的属性会被冻结。

`Object.freeze(*object*)`和`const`表达式做的是完全不同的事。 `Object.freeze`作用于值，而`const`则作用于变量。如果将可变对象赋值给一个`const`变量（常量），你还是可以改变这个对象里的内容，但是无法为这个变量赋另一个值。如果将不可变对象赋值给一个普通的变量，那么你将不能改变变量里的内容，但是可以为变量赋另一个值。

```
Object.freeze(my_copy);
const my_little_constant = my_little_object;

my_little_constant.foo = 7;
// 允许
my_little_constant = 7;
// 语法错误！
my_copy.foo = 7;
// 异常！
my_copy = 7;
// 允许 **但是my_copy不会改变！**
```

### 8.6 莫使冻结共原型

原型的一个用处是创建对象的轻量级副本。假如我们有两个对象，其中一个有各种数据，而我们想让另一个包含相同的数据，只不过有一个属性略微不同。在这种情况下，就可以使用`Object.create`。前文已经介绍过，这里不再赘述。这种方式会节约我们在创建对象时耗费的时间，但是在访问属性的时候，可能需要检索整条原型链，因此会耗费更多的时间。

**但是，如果原型被冻结，就会出问题。如果对象原型中的一个属性是不可变的，那么该对象就无法拥有同名的自有属性了。**

在某些函数式编程风格中，我们大多希望所有的对象都是不可变对象，以此来换取系统的可靠性。如果可以从冻结的原型中继承出一个对象，然后更新该对象并冻结它就好了。然而，这是行不通的，修改从冻结原型继承过来的属性会触发异常。**此外，这种形式的继承会降低插入新属性的性能。每当我们插入新属性的时候，系统会在整条原型链中搜索是否存在该不可变属性。这种烦人的搜索在`Object.create(null)`中可以被避免。**

### 8.7 WeakMap

JavaScript 的一个设计错误是对象上的属性名必须为字符串。有时候，我们的确需要用一个对象或者数组作为键名。很可惜的是，JavaScript 中的对象会在这种情况下做一件蠢事——直接把要作为键名的值通过`toString`方法进行转换。我们之前也看到了，对象的`toString`方法返回的完全是糟粕。

**`WeakMap`和对象的差异**

|              对象               |         `WeakMap`          |
| :-----------------------------: | :------------------------: |
| `object = Object.create(null);` | `weakmap = new WeakMap();` |
|          `object[key]`          |     `weakmap.get(key)`     |
|     `object[key] = value;`      | `weakmap.set(key, value);` |
|      `delete object[key];`      |   `weakmap.delete(key);`   |

我个人认为，这两种类型用完全不同的语法做相同的事情实在没有意义。更没有意义的是，它们居然不是一种东西。一种只允许字符串作为键名，而另一种居然只允许对象作为键名。就不能好好地设计出一种既支持字符串又支持对象作为键名的类型吗？

假设我们想将一个私密的属性存储到一个对象上。那么，为了访问到这个私密属性，就需要能访问该对象并能获取密钥，二者缺一不可。这个时候，就轮到`WeakMap`出马了。我们将`WeakMap`作为密钥存储装置。

```
const secret_key = new WeakMap();
secret_key.set(object, secret);

secret = secret_key.get(object);
```

如你所见，必须获取密钥和存储私密属性的对象才行。这种做法的好处在于，我们可以安全地将一个私密属性存储在一个冻结对象中。

再假设我们想为一个对象写一些可能有用的代码，如对其索引以供未来使用。但我们不想这些代码拥有调用该对象方法的能力，也不想它们能修改对象本身。用现实生活中的例子做类比，就是我们希望酒店可以代客泊车，但是又不想让他们擅动我们的手套箱、后备箱，甚至直接偷偷把车卖掉。在现实生活中，解决这个问题的办法是建立信用体系，但是计算机网络中的代码可不吃这一套。

因此，我们可以制造一套封箱机制。我们将对象存入封箱，封箱会返回一个无法打开的盒子，而这个盒子就可以交给“泊车员”了。如果需要拿到原始对象，只需将盒子交给拆封员即可。与上一个例子同理，我们可以用`WeakMap`方便地实现这一套机制。

```
function sealer_factory() {
    const weakmap = new WeakMap();
    return {
        sealer(object) {
            const box = Object.freeze(Object.create(null));
            weakmap.set(box, object);
            return box;
        },
        unsealer(box) {
            return weakmap.get(box);
        }
    };
}
```

JavaScript 还有一种类似的数据类型，名为`Map`。但相较而言，它并没有`WeakMap`的安全性和内存泄漏防护机制。既然说到了这一点，我还是忍不住抱怨一下：`WeakMap`这个名字起得就够差劲了，`Map`更不知所云。它与数组的`map`方法没有半点关系，更与绘制地图毫不沾边。所以我一直不推崇`Map`，但是`WeakMap`和数组的`map`方法则是吾之所爱。

JavaScript 还有一种叫`Symbol`的类型，具有`WeakMap`的一些能力。但我不推荐使用`Symbol`，因为它真的很多余。我个人的习惯就是不使用各种多余的功能，以此来简化操作。

## 第九章 字符串

### 9.1 根基

字符串在本质上是**16 位无符号整数（0 过 65 535）**的不可变数组。我们可以通过`String.fromCharCode`函数来创建字符串，该函数接收任意多个参数。字符串中的元素可以通过`charCodeAt`访问，但是不可以修改——字符串是不可变的。与数组一样，字符串也拥有`length`属性。

> String.fromCharCode 方法返回由指定的 UTF-16 代码单元序列创建的字符串。

```
const my_little_array = [99, 111, 114, 110];
const my_little_string = String.fromCharCode(...my_little_array);
my_little_string.charCodeAt(0) === 99
// true
my_little_string.length
// 4
typeof my_little_string
// "string"
```

可以用方括号表示法获取字符串中某一位的值。只不过该值不是数，而是一个新的字符串，该字符串只包含一位原字符串对应位置的字符。

```
my_little_string[0] === my_little_array[0]
// false
my_little_string[0] === String.fromCharCode(99)
// true
```

用`===`（全等运算符）判断两个包含相同内容的字符串会返回`true`；而两个包含相同内容的数组则只在来自同一个引用的情况下才会被`===`认为是`true`。

字符串的全等运算非常有用。这也是我认为不需要`Symbol`的原因之一，毕竟内容相同的字符串会被认为是同一个对象。

> Symbol：每个从`Symbol()`返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。

### 9.2 统一码

字符串字面量表示为由双引号（`"`）或者单引号（`'`）包围的零个、一个或多个统一码字符。我个人不推荐使用单引号。字符串中的每个元素都会被视为一个 16 位的元素。

字符串字面量必须在一行内完成。反斜杠（`\`）用于转义双引号、反斜杠和换行符等。

所有字符串在创建出来的时候都被冻结了。也就是说，一旦字符串被生成，你就无法再修改它了。我们可以从字符串中提取子串，不过这些子串也是全新的字符串。拼接操作也能将多个字符串拼接成一个新的字符串。

统一码赋予了 JavaScript**字符**两个不同的术语：**代码单元**（code unit）和**代码点**（code point）。代码单元就是一个 16 位字符，而代码点则是该字符串对应的数。一个代码点可以包含一个或多个代码单元。

### 9.4 模板字符串字面量

## 第十章 底型

底型是用于指示递归数据结构结尾的特殊值，也可用于表示值不存在。在一般的编程语言中，常以`nil`、`none`、`nothing`或者`null`表示。

JavaScript 有两种底型：`null`和`undefined`。其实`NaN`也可以算作一种底型，主要用于表示不存在的数值。不过我认为过多底型属于语言设计上的失误。

在 JavaScript 中，可以说只有`null`和`undefined`不是对象。如果基于它们去访问一些属性，就会触发异常。

如果只保留两者之一，程序将更美好。我们虽然不可能改变 JavaScript 这门编程语言来只留一种底值，但是可以从自身做起，只用一种**2**。我个人建议淘汰`null`，只用`undefined`。

> 我以前也信奉这条，也是这么去做的。例如`callback()`约定俗成第一位是`err`，没有异常的时候我从来都是传`undefined`，用于对齐生态的偷懒写法是只写一个`callback()`而不传任何参数。但一个人这么写架不住整个社区都在滥用，尤其是在`node_modules`这个黑洞出现之后。——译者注

此外，`null`在编程和数据结构上下文中，语义都是约定俗成的，而`undefined`并没有。何况`undefined`这个命名本身就有歧义。它并不是数学家所说（数学范畴）的**未定义**，而是程序员所说（计算机范畴）的**未定义**。

综上所述，看起来`null`才是更合适的选择，那么为什么我还是建议使用`undefined` 呢？因为 JavaScript 自身也在用`undefined`。如果你用`let`或者`var`声明一个变量却没有初始化它，这个值就是`undefined`。这其实很神奇，你定义了一个未定义（`undefined`）的变量。如果你调用一个函数，却没往其中传入足量的参数，那么那些没有传参数的值就是`undefined`；如果你访问一个对象中不存在的属性，得到的也是`undefined`；数组也一样，如果你访问其中不存在的元素，得到的还是`undefined`。

只有在创建空对象的时候，我才会使用`null`——`Object.create(null)`。不过我也是不得已而为之，因为`Object.create()`或者`Object.create(undefined)`会触发异常，这是语言规范的设计错误造成的。

你有时候可以看到一些遗留代码中有`(typeof my_little_bottom === "undefined")`，这也可行。`(typeof my_little_bottom === "null")`则是错误的写法，因为`typeof null`的值是`"object"`，而不是`"null"`。更糟糕的是，`(typeof my_little_object === "object")`这种写法在`my_little_object的`值为`null`的时候错误地返回`true`，这就有可能导致一些程序逻辑上的错误。这也是我认为应该避免使用`null`的原因之一。

如果`my_little_person`对象上不存在`name`，甚至连`my_little_person`本身就是`undefined`，就会触发异常。所以你并不能将点号（`.`）或者下标（`[ ]`）的调用链看成一条完全正确的访问路径，而是必须考虑一些边界情况。所以应该将其改成如下代码。

```
my_little_first_name = (
    my_little_person
    && my_little_person.name
    && my_little_person.name.first
);
```

## 第十一章 语句

### 11.1 声明

JavaScript 有三种语句可以在模块或者函数中声明变量：`let`、`function`和`const`。当然，其实还有一个过时的`var`，以前用于 Internet Explorer，不过这款浏览器现在已经没人疼没人爱了。

`let`语句会在当前作用域中声明一个新变量。所有的区块（包裹在花括号中的语句）都会创建一个作用域。在一个作用域中声明的变量在该作用域外不可用。`let`语句在声明变量的时候还可以附带一个初始值，不过这一步是可选的。如果变量并未被赋上初始值，那么它的值就是`undefined`。

注意， `function`声明不需要以分号结尾，而`let`和赋值语句需要。

`function`声明会被提升。也就是说，在运行时该语句的声明会被提升到模块或者函数的顶部。所有通过`function`语句创建出来的`let`语句也会被提升。所以`function`声明不应该被放到某一个区块中，而应该置于一个函数体或者模块内。

`const`语句与`let`类似，不过有两点不同：`const`语句的初始值是必需的，而且被声明的变量后续无法被重新赋值。我会尽可能地让变量声明使用`const`，以此来提高代码的纯度（详见第 19 章）。

> 纯度（purity）反映不确定性，值越小不确定性越低。——译者注

`const`显然是**常量**（constant）的缩写。但实际上，它们并不相同。常量意味着永恒不变、无时间性；而`const`则是短暂性的，可能在函数结束的时候消失。也就是说，每次程序或者函数运行的时候，`const`都可能有不同的值。还要注意，如果`const`声明的值是可变值，那么即使该变量不可以被重新复制，它的值还是可以被编辑的，如未被冻结的对象或者数组。`Object.freeze`是作用于值的，而`const`则作用于变量。**我们非常有必要理解值与变量的区别：变量包含对一个值的引用，而值则从来不会包含变量**

### 11.2 表达式

赋值运算符：

- `=`（赋值）
- `+=`（加法赋值）
- `-=`（减法赋值）
- `*=`（乘法赋值）
- `/=`（除法赋值）
- `%=`（取余赋值）
- `**=`（幂赋值）
- `>>>=`（右移赋值）
- `>>=`（带符号扩展右移赋值）
- `<<=`（左移赋值）
- `&=`（位运算与赋值）
- `|=`（位运算或赋值）
- `^=`（位运算异或赋值）

我不建议使用自增运算符`++`或者`--`。这两个运算符都是早期设计出来用于操作指针的。指针是编程上的一道坎，没多少人能真正用好它。因为弊大于利，所以很多现代语言已经不再允许开发者们直接操作它了。

`++`有前置和后置两种形式。这两种形式都是合法的，会给我们调试、查找问题徒增很多困难。此外，`++`还有可能造成缓冲区溢出的错误，以及各种安全问题。我们应该抛弃这个毫无用处且危险的特性。

表达式语句并不纯，因为赋值语句与`delete`使得程序拥有不确定性。当我们调用一个不关心返回值的函数时，主要是为了其副作用。表达式语句是所有语句中唯一不以关键字开头的语句。这种语法是在从根本上鼓励不确定性。

### 11.3 　分支

JavaScript 有两种分支语句：`if`和`switch`。我们其实只需要一个，甚至都不需要。

我不推荐使用`switch`，它真的是托尼·霍尔的`case`语句与 FORTRAN 的`goto`语句的邪恶结合体。`if`完全可以实现`switch`可以实现的所有逻辑，甚至可以写得更为紧凑。`switch`语句会提供一个隐式的 switch 变量，但是有导致错误的风险，是一个不良实践。

如果前一个区块是以中断（如`return`等）为结尾的，就不应当使用`else if`。

当我们以纯函数式的风格编写程序时，还有一种更好的写法——三目运算。不过三目运算符也经常被滥用，以至于风评一直不好。我们应当将整个三目运算表达式以括号包围，并在左圆括号之后换行，然后将条件语句以及两个分支对齐书写。

JavaScript 有三种循环语句：`for`、`while`和`do`。我们其实只需要一个，甚至都不需要。

`for`语句是 FORTRAN 中`DO`的后裔。两者都可以一次处理数组的一个元素，而大部分的变量管理工作等由程序员来自行处理。我们应当用数组的`forEach`方法来代替这种做法，这样就省得处理一些流程控制的变量了。我希望在 JavaScript 语言未来的某个版本中，数组的这些方法有并行处理的能力。写得不好的程序通常一次只用`for`语句处理一个元素。

我个人认为最好的循环写法是使用尾递归。

### 11.5 　中断

JavaScript 中有四种中断语句（disruptive statement）来丰富控制流，其中并没有`goto`！它们分别是`break`、`continue`、`throw`和`return`。

`break`语句用于退出循环。此外，它还可用于退出`switch`语句。但是如果`switch`语句在循环当中，情况就复杂了。

`continue`语句是一种特殊的`goto`语句，用于跳到循环语句的顶部。我见过的所有包含`continue`的程序都能在将其移除后得到优化。

`throw`语句用于抛出异常。

### 11.6 标点

表达式语句、`do`语句、中断语句和`debugger`语句都应当以分号（`;`）结尾。

## 第十二章 函数

`function`运算符用于创建函数。函数由形参列表和函数体组成，而函数体就是一个语句区块。

形参列表中的参数名是可以在函数中使用的变量名，由传入函数的表达式初始化。每个形参后面都可以跟一个等号（`=`）和表达式。如果对应参数的值是`undefined`，那么后面跟着的表达式就会被用作该参数的默认值。

三点省略号（`...`）在实参列表和形参列表中均可出现。当出现在实参列表中时，它被称为 spread 参数，会将一个数组展开，并将数组中的每个元素依次作为传入函数对应位置的实参；而当出现在形参列表中时，它被称为 rest 参数，从在实参中传入的当前位置起，所有参数都将被合成一个数组中的对应元素以供函数体使用。形参列表中的 rest 参数必须是整个参数列表的最后一个参数。这种特性可以让函数拥有动态数量个参数。

JavaScript 从一个堆中分配该对象，跟日常用的对象没什么两样。此外，活跃对象并不会在函数返回时被自动销毁，它的生命周期与普通对象的垃圾回收机制一样，是根据引用数量决定的。

活跃对象包含：

- 对应函数对象的引用；
- 调用者对应的活跃对象，用于`return`之后的控制权转移；
- 调用完毕之后用于继续执行后续逻辑的恢复信息，通常是一个将在函数调用完毕之后立即执行的指令的地址；
- 函数对应的形参，从实参初始化而来；
- 函数中的变量，以`undefined`进行初始化；
- 函数用于计算复杂表达式的临时变量；
- `this`（如果函数作为一个方法被调用，那么`this`通常就是它的宿主对象）。

函数对象还有如下两个隐藏的属性。

- 当前函数可执行代码的引用。
- 当函数对象被创建的时候，这个函数对应的活跃对象就被激活了，从而为闭包提供了可能性。函数可以通过这个隐藏属性去访问函数中创建它的变量。

拥有“外层函数对象所对应的活跃对象引用”的函数对象就被称为**闭包**（closure）。

## 第十三章 生成器

ES6 引入了一个新特性，叫**生成器**（generator）。当时，标准的制定过程受到了 Python 的极大影响，生成器也应运而成。但是出于一些原因，我个人不建议使用生成器。

生成器的代码看上去与其实际用途相差甚远。它看起来与传统的函数很像，但是执行起来天差地别。生成器用`function*`函数体创建函数对象，而该函数对象则会产生包含`next`方法的对象。它有一个与`return`语句类似的`yield`运算符，但是产生的值不是期望的返回值，而是一个包含`value`属性的对象，`value`属性中的才是期望的返回值。一个小小的星号（`*`）就会带来巨大的行为差异。

生成器建议多使用循环。不过将目光从对象转向函数的时候，我们应该远离循环。生成器反而期望大家使用**更多**循环。绝大多数生成器包含循环，而在循环体中又常伴以`yield`来产生各种值。使用者则通常用`for`循环去消费生成器产生的内容。生产侧一个循环，消费侧又一个循环，而实际上这两个循环都是不必要的。

生成器使用一种粗糙的面向对象接口。工厂生成一个对象，而生成器也返回一个对象。（在函数式设计中，工厂生成的是生成器函数，生成器函数才生成它对应的值。很明显，函数式设计更简明易用。）

上面这些都还好说，最糟糕的是 ES6 的生成器完全没有存在的必要。当有更好的选择时，我建议你不要用生成器。

```
function* counter() {
    let count = 0;
    while (true) {
        count += 1;
        yield count;
    }
}

const gen = counter();

gen.next().value
// 1
gen.next().value
// 2
gen.next().value
// 3
```

想想我刚才的话，用更好的实现方式吧！

```
function counter() {
    let count = 0;
    return function counter_generator() {
        count += 1;
        return count;
    }
}

const gen = counter();

gen()
// 1
gen()
// 2
gen()
// 3
```

## 第十四章 异常

### 14.1 层层递进

异常管理很重要的一个目标就是，在实现其价值的前提下，不对正确运行的程序造成性能损失。触发异常的时候可能会有一定的性能损失，但是这在理论上是少数情况，而且即使触发，代价也不是很昂贵。

JavaScript 编译器会为每个函数生成一个捕获图。捕获图会将函数体中的指令位置映射到处理这些位置的`catch`中去。函数在正常执行的时候并不会用到这些捕获图。

当前函数执行到`throw`语句的时候，就会触发一个异常，继而询问该函数的捕获图。如果能找到对应的`catch`块，那么该块就会获得程序的控制权，并继续执行。

如果未能找到对应的`catch`，那么该函数将调用者设为“当前函数”，而调用刚才抛出异常的函数的位置就变成了新的异常触发位置。这个时候，“当前函数”的捕获图会再一次被询问。同样，若能找到对应的块，则获取控制权继续并执行。

如此层层递进，可以找到对应`catch`块的位置。如果直到调用栈底部还未找到`catch`块，就得到了一个未捕获的异常（uncaught exception）。

### 14.2 普通异常

错误恢复很难，对其进行测试难上加难。所以我们应该采用一种简单可靠的方式，将所有的预期结果都作为返回值，只抛出真正的异常。

## 第十六章 this

> 去 this 化

## 第十七章 非类实例对象

### 17.1 构造函数

> 此处所说的构造函数是非类实例对象的构造函数概念，并非传统面向对象编程中所说的构造函数。——译者注

### 17.2 构造函数参数

只让构造函数有一个参数。这个参数是一个对象，通常是以对象字面量的形式传入的，但有时候也可以来自其他代码源，如 JSON 数据。

这么做有好几个好处：

- 键名可以让代码本身成为“文档”，当我们读到代码的时候，就能明白每个字段的含义；
- 参数无须按顺序传入；
- 以后可以无痛新增参数；
- 过时的参数会被忽略，并不一定要删除。

```
function my_little_constructor(spec) {
    let {
        name, mana_cost, colors, type, supertypes, types, subtypes, text,
        flavor, power, toughness, loyalty, timeshifted, hand, life
    } = spec;
```

## 17.2 　构造函数参数

我曾经写过有 10 个参数的构造函数。它太难用了，谁都记不住参数的顺序。后来，我发现第二个参数没什么用。虽然我想将其从参数列表中移除，但这么一来就会破坏已经写好的代码。

后来我学聪明了，只让构造函数有一个参数。这个参数是一个对象，通常是以对象字面量的形式传入的，但有时候也可以来自其他代码源，如 JSON 数据。

这么做有好几个好处：

- 键名可以让代码本身成为“文档”，当我们读到代码的时候，就能明白每个字段的含义；
- 参数无须按顺序传入；
- 以后可以无痛新增参数；
- 过时的参数会被忽略，并不一定要删除。

这个参数通常用于初始化对象的私有属性，例如：

```
function my_little_constructor(spec) {
    let {
        name, mana_cost, colors, type, supertypes, types, subtypes, text,
        flavor, power, toughness, loyalty, timeshifted, hand, life
    } = spec;
```

你看，这就从`spec`中初始化了 15 个私有变量。如果`spec`缺失了其中的某几个属性，那么对应变量会被初始化成`undefined`。这也为我们设置默认值提供了可能性。

## 第十八章 尾调用

**尾调用优化**（tail call optimization）就是这样一种优化。很多专家认为这种优化本来就应该存在于日常开发中，而不应该作为一种优化手段。它在规范中被称为**正确的尾调用**”（proper tail call），所有其他尾调用的实现都是不正确的。

当一个函数做的最后一件事是返回另一个函数的返回结果时，就出现了尾调用。在下面的示例中，`continuize`是一个接收任意返回类型函数`any`的函数，而它的返回值是一个`hero`函数。在`hero`函数中调用`any`函数，并将返回值作为参数传给`continuation`。

```
function continuize(any) {
    return function hero(continuation, ...args) {
        return continuation(any(...args));     // <-- 尾调用
          };
}
```

当一个函数返回另一个函数的返回值时，我们就称其是一个**尾调用**。说起来真可笑，我们居然不称其为**返回调用**。

尾调用优化很简单，却意义深远。用传统的指令集打比方的话，`continuize`生成的指令包含：

```
call continuation # 调用continuation函数
return            # 返回到调用hero的函数
```

`call`指令将下一个指令的地址（在这里是`return`）推入调用栈，然后将控制权转交给在寄存器中被标记为`continuation`的地址对应的函数。当`continuation`函数执行完毕的时候，它就会将栈中`return`的地址推出并跳转到该地址。然后`return`指令会继续将栈顶元素推出，继而跳转到之前调用`hero`指令之后的一个指令。

尾调用优化则将两个指令合并成一个指令：

```
jump continuation # 跳转到continuation函数
```

从表象上看，该优化好像只减少了一个指令、一次入栈和一次出栈，看起来并没什么大不了的。为了加深对尾调用好处的理解，我们接下来看看它在 JavaScript 中是怎么实际运作的。正常情况下，当你在调用函数的时候，逻辑如下。

- 计算实参表达式。
- 创建一个足以容纳函数所有形参和变量大小的新活跃对象（activation object）。
- 将当前正在调用的函数引用存入新活跃对象。
- 将实参存入新活跃对象的实参列表，缺失的实参会被定义为`undefined`，而多余的实参则会被忽略。
- 将所有的变量都以`undefined`存入新活跃对象。
- 将新活跃对象中的`next instruction field`设置为函数执行完毕后需要立即执行的指令。
- 将当前活跃对象存入新活跃对象中的`caller`字段，要知道调用栈在 JavaScript 中只是一个概念，它实际上是活跃对象的链表。
- 将新活跃对象设为“当前活跃对象”。
- 开始执行被调用函数。

优化后会略有不同。

- 计算实参表达式。

- 如果当前活跃对象足够大，则：

  - 直接把当前活跃对象设为新活跃对象。

  否则：

  - 创建一个足以容纳函数所有形参和变量大小的新活跃对象；
  - 将当前活跃对象的`caller`字段直接赋值给新活跃对象；
  - 直接将新活跃对象设置为“当前活跃对象”。

- 将当前正在调用的函数引用存入新活跃对象。

- 将实参存入新活跃对象的实参列表，缺失的实参会被定义为`undefined`，而多余的实参则会被忽略。

- 将所有的变量都以`undefined`存入新活跃对象。

- 开始执行被调用函数。

最大的区别在于，如果当前活跃对象足够大（其实通常是足够大的），我们无须分配一个新的活跃对象，而是直接复用当前的活跃对象。调用栈链不能很长，链长通常不到 1000，所以在存在尾调用的情况下，总是分配一个理论上足够大的活跃对象是非常有必要的。减少内存分配和垃圾回收的时间非常重要，而且尾调用的优势还不只这些。

有了尾调用优化，递归函数就可以跟循环一样快了。这一点很重要，因为循环天生不纯（impure），递归才纯（pure）。有了尾调用优化，递归就克服了它在性能上的缺陷。

上面的代码展示了循环和递归之间的对应关系。递归函数实现起来通常更优雅——通过参数来更新状态，通过返回值来代替原有的赋值操作。

这么一来，我们就可以递归到任何深度，而不用担心调用栈溢出或者内存耗尽。书写良好的递归函数可以流畅地运行，所以“正确的尾调用”并不是一项特性，而是对 bug 的修复。规范之所以要求解释器实现尾调用优化，是因为拥有良好尾调用的程序值得采用它。

### 18.1 尾调用位

所谓尾调用，就是函数的返回值是另一个函数的直接返回值。例如：

```
return (
    typeof any === "function"
    ? any()                                         // <-- 尾调用
    : undefined
);
```

就是一个尾调用。返回表达式如果含有逻辑与（`&&`）或者逻辑或（`||`），也可成为尾调用。但像

```
return 1 + any();                                   // <-- 不是尾调用
```

这样就不是尾调用。因为它的返回值不是另一个函数的直接返回值，而是在最后做了加法运算的返回值。

```
any();                                              // <-- 不是尾调用
return;
```

上面的代码也不是尾调用，因为它返回的是`undefined`，而不是`any()的`返回值。

```
const value = any();                                // <-- 不是尾调用
return value;
```

上面的代码也不是尾调用，因为它的返回值是常量`value`。虽然我们都知道`value`就是`any()`的返回值，但是返回值不在尾调用位（tail position）上。

很多情况下的递归也不是尾调用。

```
function factorial(n) {
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);                    // <-- 不是尾调用
}
```

> 此时的复杂度为 O(n)

`factorial`并不在尾调用位上，所以每次迭代的时候都会生成一个新的活跃对象。但是稍作修改就能将其放到尾调用位上了：

```
function factorial(n, result = 1) {
    if (n < 2) {
        return result;
    }
    return factorial(n - 1, n * result);            // <-- 尾> 调用
}
```

> 此时的复杂度为 O(1)

这个版本就经过尾调用优化了，递归时并不会生成新的活跃对象，而是重回函数顶端，然后用新的实参去刷新形参。

只返回一个函数又不执行时，并不会触发尾调用，

```
return function () {};                              // <-- 不是尾调用
```

除非马上执行它。

```
return (function () {}());                          // <-- 尾调用
```

### 18.2 例外

`try`块中不能进行尾调用优化。为了节省内存和时间，尾调用优化不会将新调用的激活对象链接进调用栈。但`try`则有可能将控制权交给调用该函数作用域的`catch`，所以激活对象不能被缩减。这也是不应该滥用异常的一个理由。

如果在函数内部创建了一个新的函数对象，而新函数用到了任何自由变量（free variable），新函数就必须有权访问其创建者的激活对象。在这种情况下，激活对象也不能被优化掉。

### 18.3 续体传递风格

在续体传递风格（continuation-passing style）中，函数会加上一个额外的`continuation`参数用于接收结果。本章一开始的`continuize`工厂就可以将任何函数转变为带有`continuation`的函数。在这种编程风格中，`continuation`就是一个用于让程序继续执行的函数。程序流程会一直向前推进，很少会重新访问以前的状态。这是管理事件的利器，通常用于转译和其他应用程序中。是尾调用优化让这种风格有了实现的可能。

## 第十九章 纯度

### 19.1 高纯度的好处

高纯度带来的价值是非常可观的。

高纯度通常意味着出色的模块化设计。纯函数具有极高的内聚性，其中的一切都在为了产出单个结果而努力，没有破坏内聚性的事物存在；纯函数具有极低的耦合性，其结果只依赖于输入。写出好的模块并不容易事，但如果采用纯函数的方式，就不再是难事了。

### 19.2 纯之门路

高纯度显然给我们带来了很多好处。那么可以为语言增加纯度吗？答案是不可以。跟安全性和可靠性一样，纯度并不是一种可以被添加的特性。我们无法增加系统的可靠性，只能消除不可靠性；也无法增加安全性，只能消除不安全性。同理，我们不能增加纯度，只能剔除不纯的内容。不纯的内容就是让我们的函数偏离数学模型上的函数的“病灶”。

首先，必须丢弃所有的赋值运算符，以及`var`和`let`语句，只保留`const`语句。我们通过`const`来初始化变量，并且不再改变它的值。

接着，需要丢弃可以修改对象内容的运算符和方法，如`delete`运算符和`Object.assign`方法等；还要抛弃可以更改数组内容的方法，如`splice`和`sort`等。数组的`sort`方法本可以是一个纯函数，但因为 JavaScript 的`sort`方法会修改原数组，所以它很遗憾地出局了。

我们还要抛弃 getter 和 setter。后者显然是引起变化的重要手段，且两者都存在引发副作用的可能。所有副作用都是程序腐化的潜在威胁，必须消除。

正则表达式（RegExp）的`exec`函数会修改`lastIndex`属性，所以也出局了。该方法本可以不这么设计，但很可惜现在就是如此。

`for`语句的原始意图就是修改归纳变量，所以也要被丢弃。同理，我们还要丢弃`while`和`do`。尾递归才是最纯的迭代方式。

然后，我们还要弃用`Date`构造函数。每次调用它都会得到不同的值，这就是不纯的一个表现。同理，我们还应该弃用`Math.random`，你甚至无法知道它的返回值会是什么。

我们必须抛弃用户。人与程序的每次互动都会得到不同的结果。人类可不纯。

最后，切断网线吧。Lambda 计算无法表示存在于一台机器上而不存在于另一台机器上的信息，通用图灵机（universal Turing machine）也不会有 Wi-Fi 连接。

**我们应该尽可能使程序保持高纯度，因为其带来的好处是真实可见的。但这个世界就是这样的，有时候只有可变的、有状态的对象才能解决我们的问题。既然这些对象必然要存在，我们就应当对其进行设计，严格控制其状态的更改。**

## 第二十章 事件化编程

### 20.1 并发

### 20.2 线程

线程是最古老的异构并发机制之一，至今仍被广泛使用。线程就是“火力”同时全开并使用共享内存的（真实或虚拟的）CPU。如果执行纯函数，线程可以很好地运行，但如果不是纯函数，则有可能捅娄子。

### 20.3 事件化编程

**事件函数**（eventual function）是一种会立即返回的函数，可能在其要求的工作完成前就返回。它的结果通常不会直接返回，而是通过回调函数或者消息来与关心方通信。

### 20.5 服务端问题

第一个是**回调地狱**（callback hell）。每个回调函数都包含请求下一个工作单元的代码，而每个请求中又有一个回调函数，继续请求另一个工作单元，如此循环往复。用这种方式写的程序可读性、可维护性都很差，而且容易出错。

第二个是**promise**。promise 最初是一个伟大的创举，用于让人们开发出安全、分布式的系统。但遗憾的是，当它被移植到 JavaScript 中时，所有新范式的特性都没被保留下来，被保留下来的只有笨拙的流程控制机制。promise 不是为管理局部控制流而设计的，这违背了它的初心。promise 虽然是改进回调地狱的一种方式，但效果其实不尽如人意。

第三个是**async/await**。这是一对用于修饰普通顺序化代码的关键字，其神奇之处在于能将顺序化代码转换为事件化代码。它与 ES6 的生成器类似，你编写的代码与最终获得的代码非常不一致。不过我还是要夸一下，它掩盖了 promise 的很多不足之处。async/await 之所以深受喜爱，是因为可以让人们继续以旧范式的编程风格来写代码。但这其实恰恰是它最大问题之所在。

这三个误区有一个共同点，那就是将逻辑与控制流强耦合在了一起。这就必然导致低内聚，因为太多不相干的逻辑被强行粘在了一起。我们应该将它们分开。
