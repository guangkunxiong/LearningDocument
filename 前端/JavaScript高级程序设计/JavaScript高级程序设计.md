## 第二章 HTML 中的 Javascript

### 2.1 `<script>`元素

<script>元素有八个属性

- `async`：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
- `charset`：可选。使用`src`属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
- `crossorigin`：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。`crossorigin="anonymous"`配置文件请求不必设置凭据标志。`crossorigin="use-credentials"`设置凭据标志，意味着出站请求会包含凭据。
- `defer`：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
- `integrity`：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，`Subresource Integrity）`。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
- `language`：废弃。最初用于表示代码块中的脚本语言（如`"JavaScript"`、`"JavaScript 1.2"`或`"VBScript"`）。大多数浏览器都会忽略这个属性，不应该再使用它。
- `src`：可选。表示包含要执行的代码的外部文件。
- `type`：可选。代替`language`，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是`"text/javascript"`，尽管`"text/javascript"`和`"text/ecmascript"`都已经废弃了。JavaScript文件的MIME类型通常是`"application/x-javascript"`，不过给type属性这个值有可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有`"application/javascript"`和`"application/ecmascript"`。如果这个值是`module`，则代码会被当成ES6模块，而且只有这时候代码中才能出现`import`和`export`关键字。

在使用行内JavaScript代码时，要注意代码中不能出现字符串`</script>`。

浏览器解析行内脚本的方式决定了它在看到字符串`</script>`时，会将其当成结束的`</script>`标签。想避免这个问题，只需要转义字符“\”1 即可

```
<script>
  function sayScript() {
    console.log("<\/script>");
  }
</script>
```

**注意**　按照惯例，外部 JavaScript 文件的扩展名是`.js`。这不是必需的，因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为 JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用`.js`扩展名，一定要确保服务器能返回正确的 MIME 类型。

#### 2.1.1 　标签占位符

把所有 JavaScript 文件都放在`<head>`里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到`<body>`的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在`<body>`元素中的页面内容后面，

#### 2.1.2 　推迟执行脚本

HTML 4.01 为`<script>`元素定义了一个叫`defer`的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。在`<script>`元素中设置`defer`属性，相当于告诉浏览器**立即下载，但延迟执行**。

HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在`DOMContentLoaded`事件之前执行（关于事件，请参考第 17 章）。

**`defer`属性只对外部脚本文件才有效。**

对`defer`属性的支持是从 IE4、Firefox 3.5、Safari 5 和 Chrome 7 开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。

> **注意**　对于 XHTML 文档，指定`defer`属性时应该写成`defer="defer"`。

#### 2.1.3 　异步执行脚本

HTML5 为`<script>`元素定义了`async`属性。从改变脚本处理方式上看，`async`属性与`defer`类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与`defer`不同的是，标记为`async`的脚本并不保证能按照它们出现的次序执行。

异步脚本保证会在页面的`load`事件前执行，但可能会在`DOMContentLoaded`（参见第 17 章）之前或之后。

使用`async`也会告诉页面你不会使用`document.write`，不过好的 Web 开发实践根本就不推荐使用这个方法。

#### 2.1.4 　动态加载脚本

除了`<script>`标签，还有其他方式可以加载脚本。因为 JavaScript 可以使用 DOM API，所以通过向 DOM 中动态添加`script`元素同样可以加载指定的脚本。只要创建一个`script`元素并将其添加到 DOM 即可。

```
let script = document.createElement('script');
script.src = 'gibberish.js';
script.async = false;//设置为同步加载
document.head.appendChild(script);
```

默认情况下，以这种方式创建的`<script>`元素是以异步方式加载的，相当于添加了`async`属性。

#### 2.1.5 　 XHTML 中的变化

可扩展超文本标记语言（XHTML，Extensible HyperText Markup Language）是将 HTML 作为 XML 的应用重新包装的结果。与 HTML 不同，在 XHTML 中使用 JavaScript 必须指定`type`属性且值为`text/javascript`，HTML 中则可以没有这个属性。XHTML 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码。

### 2.2 　行内代码与外部文件

但通常认为最佳实践是尽可能将 JavaScript 代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。

- **可维护性**。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。
- **缓存**。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
- **适应未来**。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。

在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。

从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript 文件的延迟差不多。

在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。

**在支持 http2 的浏览器中使用多个独立的资源更优，由于带宽更大所以请求多次分批加载并不会带来多少性能的损耗，第二次加载更轻量的缓存让你加载更快，而且更适合按需加载**

### 2.3 　文档模式

IE5.5 发明了文档模式的概念，即可以使用`doctype`切换文档模式。最初的文档模式有两种：**混杂模式**（quirks mode）和**标准模式**（standards mode）。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过 CSS 渲染的内容方面，但对 JavaScript 也有一些关联影响，或称为副作用。本书会经常提到这些副作用。

## 第三章 语言基础

### 3.1 语法

#### 3.1.1 　区分大小写

#### 3.1.2 　标识符

- 第一个字符必须是一个字母、下划线（`_`）或美元符号（`$`）；
- 剩下的其他字符可以是字母、下划线、美元符号或数字。

#### 3.1.3 　注释

#### 3.1.4 　严格模式

要对整个脚本启用严格模式，在脚本开头加上这一行：

```
"use strict";
```

严格模式会影响 JavaScript 执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。

#### 3.1.5 　语句

即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。

```
// 有效，但容易导致错误，应该避免
if (test)
  console.log(test);
```

### 3.2 　关键字与保留字

### 3.3 　变量

#### 3.3.1 　`var`关键字

不初始化的情况下，变量会保存一个特殊值`undefined`。

```
var message = "hi";
message = 100;  // 合法，但不推荐
```

**01.`var`声明作用域**

使用`var`操作符定义的变量会成为包含它的函数的局部变量。比如，使用`var`在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：

不过，在函数内定义变量时省略`var`操作符，可以创建一个全局变量：

```
function test() {
  message = "hi";     // 全局变量
}
test();
console.log(message); // "hi"
```

**注意**　虽然可以通过省略`var`操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略`var`是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出`ReferenceError`。

**02`var`声明提升**

使用`var`时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部

```
function foo() {
  console.log(age);
  var age = 26;
}
foo();  // undefined
```

之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：

```
function foo() {
  var age;
  console.log(age);
  age = 26;
}
foo();  // undefined
```

#### 3.3.2 　`let`声明

`let`跟`var`的作用差不多，但有着非常重要的区别。最明显的区别是，`let`声明的范围是块作用域，而`var`声明的范围是函数作用域。

```
if (true) {
  var name = 'Matt';
  console.log(name); // Matt
}
console.log(name);   // Matt

if (true) {
  let age = 26;
  console.log(age);   // 26
}
console.log(age);     // ReferenceError: age没有定义
```

**01.暂时性死区**

`let`与`var`的另一个重要的区别，就是`let`声明的变量不会在作用域中被提升。

```
// name会被提升
console.log(name); // undefined
var name = 'Matt';

// age不会被提升
console.log(age); // ReferenceError：age没有定义
let age = 26;
```

在解析代码时，JavaScript 引擎也会注意出现在块后面的`let`声明，只不过在此之前不能以任何方式来引用未声明的变量。在`let`声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出`ReferenceError`。

**02.全局声明**

与`var`关键字不同，使用`let`在全局作用域中声明的变量不会成为`window`对象的属性（`var`声明的变量则会）。

```
var name = 'Matt';
console.log(window.name); // 'Matt'

let age = 26;
console.log(window.age);  // undefined
```

不过，`let`声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免`SyntaxError`，必须确保页面不会重复声明同一个变量。

**03.条件声明**

在使用`var`声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为`let`的作用域是块，所以不可能检查前面是否已经使用`let`声明过同名变量，同时也就不可能在没有声明的情况下声明它。

使用`try`/`catch`语句或`typeof`操作符也不能解决，因为条件块中`let`声明的作用域仅限于该块。

**注意**　不能使用`let`进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。

**04.`for`循环中的`let`声明**

在`let`出现之前，`for`循环定义的迭代变量会渗透到循环体外部：

```
for (var i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i); // 5
```

改成使用`let`之后，这个问题就消失了，因为迭代变量的作用域仅限于`for`循环块内部：

```
for (let i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i); // ReferenceError: i没有定义
```

```
for (var i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 你可能以为会输出0、1、2、3、4
// 实际上会输出5、5、5、5、5
```

之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的`i`都是同一个变量，因而输出的都是同一个最终值。

而在使用`let`声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个`setTimeout`引用的都是不同的变量实例，所以`console.log`输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。

```
for (let i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 会输出0、1、2、3、4
```

这种每次迭代声明一个独立变量实例的行为适用于所有风格的`for`循环，包括`for-in`和`for-of`循环。

#### 3.3.3 　`const`声明

`const`的行为与`let`基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改`const`声明的变量会导致运行时错误。

`const`声明的限制只适用于它指向的变量的引用。换句话说，如果`const`变量引用的是一个对象，那么修改这个对象内部的属性并不违反`const`的限制。

```
const person = {};
person.name = 'Matt';  // ok
```

JavaScript 引擎会为`for`循环中的`let`声明分别创建独立的变量实例，虽然`const`变量跟`let`变量很相似，但是不能用`const`来声明迭代变量（因为迭代变量会自增）：

```
for (const i = 0; i < 10; ++i) {} // TypeError：给常量赋值
```

#### 3.3.4 　声明风格及最佳实践

1. **不使用`var`**

   有了`let`和`const`，大多数开发者会发现自己不再需要`var`了。限制自己只使用`let`和`const`有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。

2. **`const`优先，`let`次之**

   使用`const`声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用`const`来声明变量，只在提前知道未来会有修改时，再使用`let`。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。

### 3.4 数据类型

ECMAScript 有 6 种简单数据类型（也称为**原始类型**）：`Undefined`、`Null`、`Boolean`、`Number`、`String`和`Symbol`。`Symbol`（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫`Object`（对象）。`Object`是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。

#### 3.4.1 　`typeof`操作符

对一个值使用`typeof`操作符会返回下列字符串之一：

- `"undefined"`表示值未定义；
- `"boolean"`表示值为布尔值；
- `"string"`表示值为字符串；
- `"number"`表示值为数值；
- `"object"`表示值为对象（而不是函数）或`null`；
- `"function"`表示值为函数；
- `"symbol"`表示值为符号。

注意`typeof`在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用`typeof null`返回的是`"object"`。这是因为特殊值`null`被认为是一个对空对象的引用。

> **注意**　严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过`typeof`操作符来区分函数和其他对象。

#### 3.4.2 　`Undefined`类型

`Undefined`类型只有一个值，就是特殊值`undefined`。当使用`var`或`let`声明了变量但没有初始化时，就相当于给变量赋予了`undefined`值：

```
let message;
console.log(message == undefined); // true
```

**注意**　一般来说，永远不用显式地给某个变量设置`undefined`值。字面值`undefined`主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（`null`）和未初始化变量的区别。

对未声明的变量，只能执行一个有用的操作，就是对它调用`typeof`。（对未声明的变量调用`delete`也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）

在对未初始化的变量调用`typeof`时，返回的结果是`"undefined"`，但对未声明的变量调用它时，返回的结果还是`"undefined"`，这就有点让人看不懂了。比如下面的例子：

```
let message; // 这个变量被声明了，只是值为undefined

// 确保没有声明过这个变量
// let age

console.log(typeof message); // "undefined"
console.log(typeof age);     // "undefined"
```

无论是声明还是未声明，`typeof`返回的都是字符串`"undefined"`。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。

**注意**　即使未初始化的变量会被自动赋予`undefined`值，但我们仍然建议在声明变量的同时进行初始化。这样，当`typeof`返回`"undefined"`时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

#### 3.4.3 　`Null`类型

`Null`类型同样只有一个值，即特殊值`null`。逻辑上讲，`null`值表示一个空对象指针，这也是给`typeof`传一个`null`会返回`"object"`的原因：

```
let car = null;
console.log(typeof car);  // "object"
```

在定义将来要保存对象值的变量时，建议使用`null`来初始化，不要使用其他值。这样，只要检查这个变量的值是不是`null`就可以知道这个变量是否在后来被重新赋予了一个对象的引用。

> 在悟道中 推荐只使用 undefined 这一种类型，来保证全局的统一。但是也说明 只有在创建空对象的时候才会使用 null，解释为不得以而为因为`Object.create()`或者`Object.create(undefined)`会触发异常

`undefined`值是由`null`值派生而来的，因此 ECMA-262 将它们定义为**表面上相等**，如下面的例子所示：

```
console.log(null == undefined);  // true
```

用等于操作符（`==`）比较`null`和`undefined`始终返回`true`。但要注意，这个操作符会为了比较而转换它的操作数（不要使用）。

即使`null`和`undefined`有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为`undefined`。但`null`不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用`null`来填充该变量。这样就可以保持`null`是空对象指针的语义，并进一步将其与`undefined`区分开来。

```
let message = null;
let age;

if (message) {
  // 这个块不会执行
}
if (!message) {
  // 这个块会执行
}
if (age) {
  // 这个块不会执行
}
  // 这个块会执行
}
```

#### 3.4.4 　`Boolean`类型

`Boolean`（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：`true`和`false`。

这两注意，布尔值字面量`true`和`false`是区分大小写的，因此`True`和`False`（及其他大小混写形式）是有效的标识符，但不是布尔值。布尔值不同于数值，因此`true`不等于 1，`false`不等于 0。

|  数据类型   |    转换为`true`的值    |        转换为`false`的值         |
| :---------: | :--------------------: | :------------------------------: |
|  `Boolean`  |         `true`         |             `false`              |
|  `String`   |       非空字符串       |         `""`（空字符串）         |
|  `Number`   | 非零数值（包括无穷值） | `0`、`NaN`（参见后面的相关内容） |
|  `Object`   |        任意对象        |              `null`              |
| `Undefined` |    `N/A`（不存在）     |           `undefined`            |

#### 3.4.5 　`Number`类型

**注意**　由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

**01 浮点值**

因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：

```
let floatNum1 = 1.;   // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数10处理
```

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。

> 0.1 转换为二进制的时候 会 0001 1001 1001 不断循环 最高存储 64 位 精度丢失

**02 值的范围**

ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在`Number.MIN_VALUE`中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在`Number.MAX_VALUE`中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的`Infinity`（无穷）值。任何无法表示的负数以`-Infinity`（负无穷大）表示，任何无法表示的正数以`Infinity`（正无穷大）表示。

要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用`isFinite()`函数，如下所示：

```
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result));  // false
```

**03 `NaN`**

有一个特殊的数值叫`NaN`，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。

如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回`Infinity`或`-Infinity`：

`NaN`有几个独特的属性。首先，任何涉及`NaN`的操作始终返回`NaN`（如`NaN/10`），在连续多步计算时这可能是个问题。其次，`NaN`不等于包括`NaN`在内的任何值。例如，下面的比较操作会返回`false`：

```
console.log(NaN == NaN); // faisNaN()
```

`isNaN()`函数可以判断是否为`NaN`

```
console.log(isNaN(NaN));     // true
console.log(isNaN(10));      // false，10是数值
console.log(isNaN("10"));    // false，可以转换为数值10
console.log(isNaN("blue"));  // true，不可以转换为数值
console.log(isNaN(true));    // false，可以转换为数值1
```

**注意**　虽然不常见，但`isNaN()`可以用于测试对象。此时，首先会调用对象的`valueOf()`方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用`toString()`方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式，本章后面会讨论。

**04 数值转换**

有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()`和`parseFloat()`。`Number()`是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。

`Number()`函数基于如下规则执行转换。

- 布尔值，`true`转换为 1，`false`转换为 0。
- 数值，直接返回。
- `null`，返回 0。
- `undefined`，返回`NaN`。
- 字符串，应用以下规则。
  - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，`Number("1")`返回 1，`Number("123")`返回 123，`Number("011")`返回 11（忽略前面的零）。
  - 如果字符串包含有效的浮点值格式如`"1.1"`，则会转换为相应的浮点值（同样，忽略前面的零）。
  - 如果字符串包含有效的十六进制格式如`"0xf"`，则会转换为与该十六进制值对应的十进制整数值。
  - 如果是空字符串（不包含字符），则返回 0。
  - 如果字符串包含除上述情况之外的其他字符，则返回`NaN`。
- 对象，调用`valueOf()`方法，并按照上述规则转换返回的值。如果转换结果是`NaN`，则调用`toString()`方法，再按照转换字符串的规则转换。

从不同数据类型到数值的转换有时候会比较复杂，看一看`Number()`的转换规则就知道了。下面是几个具体的例子：

```
let num1 = Number("Hello world!");  // NaN
let num2 = Number("");              // 0
let num3 = Number("000011");        // 11
let num4 = Number(true);            // 1
```

考虑到用`Number()`函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用`parseInt()`函数。`parseInt()`函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。

如果第一个字符不是数值字符、加号或减号，`parseInt()`立即返回`NaN`。这意味着空字符串也会返回`NaN`（这一点跟`Number()`不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，`"1234blue"`会被转换为 1234，因为`"blue"`会被完全忽略。类似地，`"22.5"`会被转换为 22，因为小数点不是有效的整数字符。

```
let num1 = parseInt("1234blue");  // 1234
let num2 = parseInt("");          // NaN
let num3 = parseInt("0xA");       // 10，解释为十六进制整数
let num4 = parseInt(22.5);        // 22
let num5 = parseInt("70");        // 70，解释为十进制值
let num6 = parseInt("0xf");       // 15，解释为十六进制整数
```

```
// 指定按16进制解析
let num = parseInt("0xAF", 16); // 175
let num1 = parseInt("AF", 16);  // 175
let num2 = parseInt("AF");      // NaN
```

`parseFloat()`函数的另一个不同之处在于，它始终忽略字符串开头的零。

```
let num1 = parseFloat("1234blue");  // 1234，按整数解析
let num2 = parseFloat("0xA");       // 0
let num3 = parseFloat("22.5");      // 22.5
let num4 = parseFloat("22.34.5");   // 22.34
let num5 = parseFloat("0908.5");    // 908.5
let num6 = parseFloat("3.125e7");   // 31250000
```

#### 3.4.6 　`String`类型

**注意**　如果字符串中包含双字节字符，那么`length`属性返回的值可能不是准确的字符数。第 5 章将具体讨论如何解决这个问题。

ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：

```
let lang = "Java";
lang = lang + "Script";
```

这里，变量`lang`一开始包含字符串`"Java"`。紧接着，`lang`被重新定义为包含`"Java"`和`"Script"`的组合，也就是`"JavaScript"`。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上`"Java"`和`"Script"`。最后销毁原始的字符串"Java"和字符串"Script"。

有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的`toString()`方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：

```
let age = 11;
let ageAsString = age.toString();      // 字符串"11"
let found = true;
let foundAsString = found.toString();  // 字符串"true"
let num = 10;
console.log(num.toString());     // "10"
console.log(num.toString(2));    // "1010"
```

如果你不确定一个值是不是`null`或`undefined`，可以使用`String()`转型函数，它始终会返回表示相应类型值的字符串。`String()`函数遵循如下规则。

- 如果值有`toString()`方法，则调用该方法（不传参数）并返回结果。
- 如果值是`null`，返回`"null"`。
- 如果值是`undefined`，返回`"undefined"`。

```
let value3 = null;
let value4;
console.log(String(value3));  // "null"
console.log(String(value4));  // "undefined"
```

**注意**　用加号操作符给一个值加上一个空字符串`""`也可以将其转换为字符串（加号操作符本章后面会介绍）。

所有插入的值都会使用`toString()`强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：

```
console.log(`Hello, ${ `World` }!`);  // Hello, World!
```

将表达式转换为字符串时会调用`toString()`：

```
let foo = { toString: () => 'World' };
console.log(`Hello, ${ foo }!`);      // Hello, World!
```

在插值表达式中可以调用函数和方法：

```
function capitalize(word) {
  return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}
console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!
```

使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的`String.raw`标签函数。

#### 3.4.7 　`Symbol`类型

#### 3.4.8 　`Object`类型

```
let o = new Object;  // 合法，但不推荐
```

每个`Object`实例都有如下属性和方法。

- `constructor`：用于创建当前对象的函数。在前面的例子中，这个属性的值就是`Object()`函数。
- `hasOwnProperty(*propertyName*)`：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如`o.hasOwnProperty("name")`）或符号。
- `isPrototypeOf(*object*)`：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）
- `propertyIsEnumerable(*propertyName*)`：用于判断给定的属性是否可以使用（本章稍后讨论的）`for-in`语句枚举。与`hasOwnProperty()`一样，属性名必须是字符串。
- `toLocaleString()`：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
- `toString()`：返回对象的字符串表示。
- `valueOf()`：返回对象对应的字符串、数值或布尔值表示。通常与`toString()`的返回值相同。

### 3.5 操作符

#### 3.5.1 　一元操作符

**一元加和减操作符**对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（`+`）表示，放在变量前头，对数值没有任何影响：

```
let num = 25;
num = +num;
console.log(num); // 25
```

**一元加和减操作符**对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（`+`）表示，放在变量前头，对数值没有任何影响：

```
let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
  valueOf() {
    return -1;
  }
};

s1 = +s1;  // 值变成数值1
s2 = +s2;  // 值变成数值1.1
s3 = +s3;  // 值变成NaN
b = +b;    // 值变成数值0
f = +f;    // 不变，还是1.1
o = +o;    // 值变成数值-1
```

#### 3.5.2 　位操作符

有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为**符号位**（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20，第二位表示 21，依此类推。如果一个位是空的，则以 0 填充，相当于忽略不计。比如，数值 18 的二进制格式为

比如，数值 18 的二进制格式为 00000000000000000000000000010010，或更精简的 10010。后者是用到的 5 个有效位，决定了实际的值

负值以一种称为**二补数**（或补码）的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到：

(1) 确定绝对值的二进制表示（如，对于-18，先确定 18 的二进制表示）；

(2) 找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0；

(3) 给结果加 1。

基于上述步骤确定-18 的二进制表示，首先从 18 的二进制表示开始：

```
0000  0000  0000  0000  0000  0000  0001  0010
```

然后，计算一补数，即反转每一位的二进制值：

```
1111  1111  1111  1111  1111  1111  1110  1101
```

最后，给一补数加 1：

```
1111  1111  1111  1111  1111  1111  1110  1101
                        1
 ----------------------------------------------
1111  1111  1111  1111  1111  1111  1110  1110
```

那么，-18 的二进制表示就是 11111111111111111111111111101110。要注意的是，在处理有符号整数时，我们无法访问第 31 位。

**按位与**

按位与操作符用和号（`&`）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。

```
let result = 25 & 3;
console.log(result); // 1
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

**按位或**

```
let result = 25 | 3;
console.log(result); // 27
25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
 OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

在参与计算的两个数中，有 4 位都是 1，因此它们直接对应到结果上。二进制码 11011 等于 27。

**按位异或**

按位异或用脱字符（`^`）表示，同样有两个操作数。下面是按位异或的真值表：

| 第一个数的位 | 第二个数的位 | 结果 |
| :----------: | :----------: | :--: |
|      1       |      1       |  0   |
|      1       |      0       |  1   |
|      0       |      1       |  1   |
|      0       |      0       |  0   |

按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。

**左移**

左移操作符用两个小于号（`<<`）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000），如下所示：

```
let oldValue = 2;              // 等于二进制10
let newValue = oldValue << 5;  // 等于二进制1000000，即十进制64
```

**有符号右移**

有符号右移由两个大于号（`>>`）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。比如，如果将 64 右移 5 位，那就是 2：

```
let oldValue = 64;             // 等于二进制1000000
let newValue = oldValue >> 5;  // 等于二进制10，即十进制2
```

#### 3.5.3 　布尔操作符

**逻辑非`** !`

逻辑非操作符由一个叹号（`!`）表示，可应用给 ECMAScript 中的任何值。

- 如果操作数是对象，则返回`false`。
- 如果操作数是空字符串，则返回`true`。
- 如果操作数是非空字符串，则返回`false`。
- 如果操作数是数值 0，则返回`true`。
- 如果操作数是非 0 数值（包括`Infinity`），则返回`false`。
- 如果操作数是`null`，则返回`true`。
- 如果操作数是`NaN`，则返回`true`。
- 如果操作数是`undefined`，则返回`true`。

**逻辑与** `&&`

- 如果第一个操作数是对象，则返回第二个操作数。
- 如果第二个操作数是对象，则只有第一个操作数求值为`true`才会返回该对象。
- 如果两个操作数都是对象，则返回第二个操作数。
- 如果有一个操作数是`null`，则返回`null`。
- 如果有一个操作数是`NaN`，则返回`NaN`。
- 如果有一个操作数是`undefined`，则返回`undefined`。

```
let found = true;
let result = (found && someUndeclaredVariable); // 这里会出错
console.log(result); // 不会执行这一行
```

```
let found = false;
let result = (found && someUndeclaredVariable);  // 不会出错
console.log(result);  // 会执行
```

由于第一个操作数是`false`，逻辑与操作符也不会对它求值，因为此时对`&&`右边的操作数求值是没有意义的。

**逻辑或** `||`

| 第一个操作数 | 第二个操作数 |  结果   |
| :----------: | :----------: | :-----: |
|    `true`    |    `true`    | `true`  |
|    `true`    |   `false`    | `true`  |
|   `false`    |    `true`    | `true`  |
|   `false`    |   `false`    | `false` |

- 如果第一个操作数是对象，则返回第一个操作数。
- 如果第一个操作数求值为`false`，则返回第二个操作数。
- 如果两个操作数都是对象，则返回第一个操作数。
- 如果两个操作数都是`null`，则返回`null`。
- 如果两个操作数都是`NaN`，则返回`NaN`。
- 如果两个操作数都是`undefined`，则返回`undefined`。

```
let found = true;
let result = (found || someUndeclaredVariable); // 不会出错
console.log(result); // 会执行
```

```
let found = false;
let result = (found || someUndeclaredVariable); // 这里会出错
console.log(result); // 不会执行这一行
```

利用这个行为，可以避免给变量赋值`null`或`undefined`。比如：

```
let myObject = preferredObject || backupObject;
```

#### 3.5.4 　乘性操作符

**乘法操作符** `*`

- 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回`Infinity`或`-Infinity`。
- 如果有任一操作数是`NaN`，则返回`NaN`。
- 如果是`Infinity`乘以 0，则返回`NaN`。
- 如果是`Infinity`乘以非 0 的有限数值，则根据第二个操作数的符号返回`Infinity`或`-Infinity`。
- 如果是`Infinity`乘以`Infinity`，则返回`Infinity`。
- 如果有不是数值的操作数，则先在后台用`Number()`将其转换为数值，然后再应用上述规则。

**除法操作符** `/`

- 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果 ECMAScript 不能表示商，则返回`Infinity`或`-Infinity`。
- 如果有任一操作数是`NaN`，则返回`NaN`。
- 如果是`Infinity`除以`Infinity`，则返回`NaN`。
- 如果是 0 除以 0，则返回`NaN`。
- 如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回`Infinity`或`-Infinity`。
- 如果是`Infinity`除以任何数值，则根据第二个操作数的符号返回`Infinity`或`-Infinity`。
- 如果有不是数值的操作数，则先在后台用`Number()`函数将其转换为数值，然后再应用上述规则。

**取模操作符**`%`

- 如果操作数是数值，则执行常规除法运算，返回余数。
- 如果被除数是无限值，除数是有限值，则返回`NaN`。
- 如果被除数是有限值，除数是 0，则返回`NaN`。
- 如果是`Infinity`除以`Infinity`，则返回`NaN`。
- 如果被除数是有限值，除数是无限值，则返回被除数。
- 如果被除数是 0，除数不是 0，则返回 0。
- 如果有不是数值的操作数，则先在后台用`Number()`函数将其转换为数值，然后再应用上述规则。

#### 3.5.5 　指数操作符

ECMAScript 7 新增了指数操作符，`Math.pow()`现在有了自己的操作符`**`，结果是一样的：

```
console.log(Math.pow(3, 2);    // 9
console.log(3 ** 2);           // 9

console.log(Math.pow(16, 0.5); // 4
console.log(16** 0.5);         // 4
```
